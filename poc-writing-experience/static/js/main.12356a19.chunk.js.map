{"version":3,"sources":["content/schema.ts","content/constants.ts","editor/utils/index.ts","content/block/Body/index.tsx","content/block/Image/index.tsx","content/block/ListItem/index.tsx","content/block/OrderedList/index.tsx","content/block/UnorderedList/index.tsx","content/block/index.ts","content/block/Headline/index.tsx","content/block/Title/index.tsx","content/block/Subtitle/index.tsx","content/block/Preformatted/index.tsx","content/mark/index.ts","content/mark/Bold.tsx","content/mark/Italic.tsx","content/mark/Underlined.tsx","content/inline/Link/index.tsx","content/inline/index.ts","samples/EMPTY_DOCUMENT.ts","editor/schema-utils/index.ts","editor/SCHEMA.ts","editor/ducks/selectors.ts","editor/ducks/actions.ts","editor/ducks/reducer.ts","editor/image/utils.ts","editor/menu/TextMenu/TextMenu.tsx","editor/menu/TextMenu/index.ts","editor/hooks/index.ts","editor/menu/BlockTypeDropdown/BlockTypeDropdown.tsx","editor/menu/BlockTypeDropdown/index.ts","editor/menu/BlockMenu/BlockMenu.tsx","editor/menu/BlockMenu/index.ts","editor/image/insert/ImageInput.tsx","editor/menu/InsertMenu/index.ts","editor/menu/InsertMenu/InsertMenu.tsx","editor/menu/BlockButton/index.ts","editor/menu/BlockButton/BlockButton.tsx","editor/menu/BlockWrapper/BlockWrapper.tsx","editor/menu/BlockWrapper/index.ts","editor/image/ImageSettings/ImageSettings.tsx","editor/image/ImageSettings/index.ts","editor/image/ImageEditor/index.ts","editor/image/ImageEditor/ImageEditor.tsx","editor/WXPEditor/placeholder/index.ts","editor/WXPEditor/WXPEditor.tsx","editor/WXPEditor/index.ts","editor/image/insert/DropPasteImagePlugin.ts","App.tsx","index.tsx"],"names":["Align","BLOCKS","headline","title","subtitle","body","unorderedlist","orderedlist","listitem","preformatted","image","INLINES","MARKS","bold","italic","underlined","ALL_MARKS","Object","values","map","mark","type","getOrInit","key","Constructor","value","addAll","set","array","forEach","add","getNodeData","node","dataKey","blockSchema","defaultValue","get","data","ImagePlacement","align","v","default","left","placement","break","BODY_SCHEMA","helper","marks","IMAGE_SCHEMA","isVoid","src","Image","props","className","elementRef","imageRef","forwardedProps","caption","ref","classNames","contentEditable","alt","LIST_ITEM_SCHEMA","nodes","match","object","ORDERED_LIST_SCHEMA","min","UNORDERED_LIST","BLOCK_COMPONENTS","children","MARK_COMPONENTS","LINK_SCHEMA","href","INLINE_COMPONENTS","onClick","evt","ctrlKey","preventDefault","stopPropagation","window","open","EMPTY_DOCUMENT","getNodeMatchTypes","flatMap","castArray","getNextBlocks","index","i","flatNode","flatten","nextNodes","nextNode","push","Array","isArray","getNodeId","nodeType","occurrence","nodeIdToNodeObject","nodeId","parseInt","GRAPH_START_NODE","getNextInGraph","graph","nodeOccurrence","possibleNodes","occurrenceNumbers","keys","filter","maxOccurrenceNumber","Math","max","memoizedSchemaDirectedGraph","memoizeOne","schema","directedGraph","mapValues","nodeOccurrenceSet","from","toConsumerFriendlyGraph","blockTypes","blocks","Set","noDocSchema","noDocNoBlockSchema","length","emptyDocSchema","suffixedBlocks","b","blockType","firstNodes","unary","entries","sIndex","sNode","undefined","Infinity","Error","JSON","stringify","matchTypes","getCurrentOccurrenceNodeId","matchType","getNextOccurrenceNodeId","nextNodeSet","nodeIds","delete","toDirectedGraph","memoizedGetPossibleBlocks","document","currentIndex","documentNode","Text","currentNode","SCHEMA","normalize","editor","args","code","child","possibleBlockType","text","block","Block","create","insertNodeByKey","moveFocusToStartOfNextText","insertText","inlines","getMarkType","Mark","getSchemaForNode","curry","state","Inline","CHANGE_VALUE","UPDATE_ACTIVE_BLOCK","UPDATE_TEXT_MENU","SET_BLOCK_MENU_OPEN","SET_BLOCK_TYPE_DROPDOWN_OPEN","trailingBlock","lastNode","size","lastNodeSchema","setIn","onChange","operations","dispatch","getState","activeBlockIndex","startBlock","startBlockPath","getPath","getActiveBlockIndex","setActiveBlockIndex","some","debouncedUpdateTextMenu","closeTextMenu","textMenu","isOpen","updateTextMenu","fragment","selection","isBlurred","isCollapsed","hasTextSelection","possibleMarks","marksForBlocksAtSelection","getLeafBlocksAtRange","Boolean","toJS","intersection","isEmpty","getPossibleMarksAtSelection","rect1","rect2","selectionRect","getSelection","rangeCount","getRangeAt","getBoundingClientRect","getTextSelectionRect","x","y","height","width","debounce","setBlockMenuOpen","isBlockMenuOpen","setBlockTypeDropdownOpen","isBlockTypeDropdownOpen","changeBlockAlign","blockIndex","isBlock","isList","changeType","splitNodes","Data","splice","toArray","newBlock","newNodes","List","changeBlockType","insertImage","imageSchema","imageBlock","insert","TextMenu","Record","DEFAULT_STATE","Value","fromJSON","parse","localStorage","getItem","IMAGE_EXTENSIONS","IMAGE_TYPES","ext","readAsDataURL","file","Promise","resolve","reject","reader","FileReader","onload","e","target","result","onerror","ICONS","mdiFormatBold","mdiFormatItalic","mdiFormatUnderline","MarkButton","markType","isSelected","onToggleMark","color","ColorPalette","light","emphasis","Emphasis","low","icon","onMouseDown","event","mapDispatchToProps","deleteLink","unwrapInline","insertLink","wrapInline","moveToEnd","toggleMark","connected","connect","hasLinks","inline","targetRect","without","activeMarks","popoverRef","useRef","isVisible","offset","staysOpenOnHover","hasParentWidth","hasParentHeight","dependencies","callback","useState","current","anchorRef","setAnchorRef","useEffect","Popover","useComputePosition","useComputePositionFromRect","Placement","BOTTOM","vertical","computedPosition","popoverRect","find","m","mdiLink","prompt","LABELS","BlockPreview","BlockComponent","buttonRef","dropdownBlockTypes","showDropdown","onClose","isClickable","onTouchStart","ALIGN_ICONS","center","mdiFormatAlignCenter","mdiFormatAlignLeft","right","mdiFormatAlignRight","BLOCK_TYPE_ICONS","mdiFormatListBulleted","mdiFormatListNumbered","ALL_DROPDOWN_TYPES","ALL_ICON_TYPES","activeNode","getIn","blockAlign","possibleAlignOptions","possibleBlockTypes","BOTTOM_START","onClickBlockTypes","iconBlockTypes","elevation","leftIcon","mdiFormatParagraph","rightIcon","mdiMenuDown","ImageInput","fileInputRef","fileSelectChange","a","files","images","includes","all","dataURLs","accept","join","selectImage","click","style","display","dataURL","before","mdiImage","Size","s","ListItemSize","tiny","insertMode","showButton","hasAlignOptions","hasBlockTypeOptions","shouldShowBlockButton","medium","mdiPlus","mdiDotsVertical","visibility","ownProps","isVoidBlock","blockPath","blockRef","setStyle","blockLineHeight","lineHeight","buttonHeight","top","useStyleAlignWithLineHeight","isRootBlock","first","isBlockActive","onMouseEnter","changeImageAlign","changeImagePlacement","closeSettings","Selection","imageHasFocus","RIGHT","closeButtonRef","imagePlacement","imageAlign","possibleAligns","imageHasNaturalWidth","naturalWidth","clientWidth","hasNaturalWidth","tabIndex","mdiClose","theme","Theme","dark","onClickPlacement","renderButton","disabled","renderPlacement","onClickAlign","renderAlign","blockHasFocus","isFocused","isOfType","renderMark","next","attributes","renderInline","renderBlockWrapper","indexOf","ImageEditor","renderBlock","renderEditor","setEditor","editorRef","_","newEditor","connectedWXPEditor","isTextMenuOpen","plugins","useMemo","CollapseOnEscape","InsertImages","extensions","endBlock","configs","blockEntries","PlaceholderPlugin","placeholder","verticalAlign","when","isCorrectType","getPlaceholderPluginConfigFromSchema","SoftBreak","shift","windowSize","getWindowSize","innerWidth","innerHeight","setWindowSize","handleResize","addEventListener","removeEventListener","useWindowSize","windowScroll","getWindowScroll","scrollX","scrollY","setWindowScroll","handleScroll","useWindowScroll","enhancer","compose","applyMiddleware","thunk","store","createStore","action","setTimeout","setItem","App","name","fields","avatar","spellCheck","ReactDOM","render","getElementById"],"mappings":"qhBAGYA,E,uHCACC,EAAS,CAClBC,SAAU,WACVC,MAAO,QACPC,SAAU,WACVC,KAAM,OACNC,cAAe,iBACfC,YAAa,eACbC,SAAU,YACVC,aAAc,eACdC,MAAO,SAMEC,EACH,OAMGC,EAAQ,CACjBC,KAAM,OACNC,OAAQ,SACRC,WAAY,cAGHC,EAAYC,OAAOC,OAAON,GAAOO,KAAI,SAAAC,GAAI,MAAK,CAAEC,KAAMD,M,wCCxB5D,SAASE,EAAaH,EAAwBI,EAAaC,GAC9D,IAAIC,EAAQN,EAAII,GAIhB,OAHKE,IACDA,EAAQN,EAAII,GAAO,IAAIC,GAEpBC,EAQJ,SAASC,EAAUC,EAAaC,GACnCA,EAAMC,QAAQF,EAAIG,IAAKH,GAepB,SAASI,EAAYC,EAAsBC,EAAiBC,GAC/D,IAAMC,EAAeC,cAAIF,EAAa,CAAC,OAAQD,EAAS,YACxD,OAAKD,EAAKK,KAGHL,EAAKK,KAAKD,IAAIH,EAASE,GAFnBA,G,SFpCHnC,K,YAAAA,E,gBAAAA,E,eAAAA,M,KASL,IAOKsC,EAPCC,EAAQ,SAACC,GAAD,OAAaA,GAAKA,KAAKxC,GAC5CuC,EAAMrB,OAASD,OAAOC,OAAOlB,GAC7BuC,EAAME,QAAUzC,EAAM0C,K,SAKVJ,K,gBAAAA,E,eAAAA,M,KAQL,IAAMK,EAAY,SAACH,GAAD,OAAaA,GAAKA,KAAKF,GAChDK,EAAUzB,OAASD,OAAOC,OAAOoB,GACjCK,EAAUF,QAAUH,EAAeM,MAK5B,I,IGzBMC,EAAc,CACvBR,KAAM,CAAEE,SAERO,OAAQ,gCACRC,MAAO/B,GCLEgC,G,cAAe,CACxBC,QAAQ,EACRZ,KAAM,CAAEa,IJ6BO,SAACV,GAAD,MAAyB,kBAANA,GI7BrBD,QAAOI,eAQXQ,EAA0B,SAACC,GAAW,IAE3CC,EAKAD,EALAC,UACAC,EAIAF,EAJAE,WACAC,EAGAH,EAHAG,SACAvB,EAEAoB,EAFApB,KACGwB,EANuC,YAO1CJ,EAP0C,8CASxCb,EAAQR,EAAYC,EAAM,QAASgB,GACnCL,EAAYZ,EAAYC,EAAM,YAAagB,GAC3CS,EAAU1B,EAAYC,EAAM,WAC5BkB,EAAMnB,EAAYC,EAAM,OAC9B,OACI,0CACI0B,IAAKJ,EACLD,UAAWM,IACPN,EACA,sBAFiB,yCAGiBV,GAHjB,yCAIiBA,EAJjB,YAI8BJ,IAEnDqB,iBAAiB,GACbJ,GAEJ,yBACIE,IAAKH,EACLM,IAAKJ,EACLJ,UAAU,6BACVH,IAAKA,IAERO,GAAW,gCAAYJ,UAAU,gCAAgCI,KC1CjEK,G,OAAmB,CAC5Bf,MAAO/B,EACP+C,MAAO,CACH,CAAEC,MAAO,CAAEC,OAAQ,SACnB,CAAED,MAAO,CAAE3C,KAAMpB,EAAOM,cACxB,CAAEyD,MAAO,CAAE3C,KAAMpB,EAAOK,mBCLnB4D,G,OAAsB,CAC/BH,MAAO,CAAC,CAAEC,MAAO,CAAE3C,KAAMpB,EAAOO,SAAU2D,IAAK,OCDtCC,G,4BAAiB,CAC1BL,MAAO,CAAC,CAAEC,MAAO,CAAE3C,KAAMpB,EAAOO,SAAU2D,IAAK,OCgBtCE,GAAgB,mBACxBpE,EAAOC,UCP8B,SAACkD,GAAW,IAE9CkB,EAKAlB,EALAkB,SACAjB,EAIAD,EAJAC,UACAC,EAGAF,EAHAE,WAEGE,GACHJ,EAFApB,KAL6C,YAO7CoB,EAP6C,+CASjD,OACI,sCACIC,UAAWM,IAAWN,EAAW,yBACjCK,IAAKJ,GACDE,GAEHc,MDTgB,cAExBrE,EAAOE,OEZ2B,SAACiD,GAAW,IAE3CkB,EAKAlB,EALAkB,SACAjB,EAIAD,EAJAC,UACAC,EAGAF,EAHAE,WAEGE,GACHJ,EAFApB,KAL0C,YAO1CoB,EAP0C,+CAS9C,OACI,sCACIC,UAAWM,IAAWN,EAAW,sBACjCK,IAAKJ,GACDE,GAEHc,MFLgB,cAGxBrE,EAAOG,UGb8B,SAACgD,GAAW,IAE9CkB,EAKAlB,EALAkB,SACAjB,EAIAD,EAJAC,UACAC,EAGAF,EAHAE,WAEGE,GACHJ,EAFApB,KAL6C,YAO7CoB,EAP6C,+CASjD,OACI,sCACIC,UAAWM,IAAWN,EAAW,yBACjCK,IAAKJ,GACDE,GAEHc,MHLgB,cAIxBrE,EAAOI,MLR0B,SAAC+C,GAAW,IAE1CkB,EAKAlB,EALAkB,SACAjB,EAIAD,EAJAC,UACAC,EAGAF,EAHAE,WACAtB,EAEAoB,EAFApB,KACGwB,EANsC,YAOzCJ,EAPyC,8CASvCb,EAAQR,EAAYC,EAAM,QAASa,GACzC,OACI,qCACIQ,UAAWM,IACPN,EACA,oBAFiB,mCAGWd,IAEhCmB,IAAKJ,GACDE,GAEHc,MKhBgB,cAKxBrE,EAAOQ,cIdkC,SAAC2C,GAAW,IAElDkB,EAKAlB,EALAkB,SACAjB,EAIAD,EAJAC,UACAC,EAGAF,EAHAE,WAEGE,GACHJ,EAFApB,KALiD,YAOjDoB,EAPiD,+CASrD,OACI,uCACIC,UAAWM,IAAWN,EAAW,6BACjCK,IAAKJ,GACDE,GAEHc,MJNgB,cAMxBrE,EAAOK,eDfmC,SAAC8C,GAAW,IAEnDkB,EAKAlB,EALAkB,SACAjB,EAIAD,EAJAC,UACAC,EAGAF,EAHAE,WAEGE,GACHJ,EAFApB,KALkD,YAOlDoB,EAPkD,+CAStD,OACI,sCACIC,UAAWM,IAAWN,EAAW,+BACjCK,IAAKJ,GACDE,GAEHc,MCNgB,cAOxBrE,EAAOM,aFhBiC,SAAC6C,GAAW,IAEjDkB,EAKAlB,EALAkB,SACAjB,EAIAD,EAJAC,UACAC,EAGAF,EAHAE,WAEGE,GACHJ,EAFApB,KALgD,YAOhDoB,EAPgD,+CASpD,OACI,sCACIC,UAAWM,IAAWN,EAAW,+BACjCK,IAAKJ,GACDE,GAEHc,MENgB,cAQxBrE,EAAOO,UHZ8B,SAAC4C,GAAW,IAE9CkB,EAKAlB,EALAkB,SACAjB,EAIAD,EAJAC,UACAC,EAGAF,EAHAE,WAEGE,GACHJ,EAFApB,KAL6C,YAO7CoB,EAP6C,+CASjD,OACI,sCACIC,UAAWM,IAAWN,EAAW,0BACjCK,IAAKJ,GACDE,GAEHc,MGXgB,cASxBrE,EAAOS,MAAQyC,GATS,GKhBhBoB,GAAe,mBACvB3D,EAAMC,MCDS,SAAC,GAAD,IAAGyD,EAAH,EAAGA,SAAUhB,EAAb,EAAaA,WAAeF,EAA5B,gDAChB,0CAAQM,IAAKJ,GAAgBF,GAAQkB,MDDb,cAEvB1D,EAAME,QEFW,SAAC,GAAD,IAAGwD,EAAH,EAAGA,SAAUhB,EAAb,EAAaA,WAAeF,EAA5B,gDAClB,sCAAIM,IAAKJ,GAAgBF,GAAQkB,MFDT,cAGvB1D,EAAMG,YGHe,SAAC,GAAD,IAAGuD,EAAH,EAAGA,SAAUhB,EAAb,EAAaA,WAAeF,EAA5B,gDACtB,qCAAGM,IAAKJ,GAAgBF,GAAQkB,MHDR,GIAfE,G,OAAc,CACvBnC,KAAM,CAAEoC,KjByBQ,SAACjC,GAAD,MAAyB,kBAANA,IiBxBnCO,MAAO,GACPgB,MAAO,CAAC,CACJC,MAAO,CAAEC,OAAQ,YCKZS,EAAiB,eACzB/D,GDIiC,SAACyC,GAAW,IAE1CkB,EAKAlB,EALAkB,SACAjB,EAIAD,EAJAC,UACAC,EAGAF,EAHAE,WACAtB,EAEAoB,EAFApB,KACGwB,EANsC,YAOzCJ,EAPyC,8CASvCqB,EAAOzC,EAAKK,MAAQL,EAAKK,KAAKD,IAAI,QAQxC,OACI,qCACIsB,IAAKJ,EACLD,UAAWM,IAAWN,EAAW,qBACjCoB,KAAMA,EACNE,QAZQ,SAACC,GACTA,EAAIC,UACJD,EAAIE,iBACJF,EAAIG,kBACJC,OAAOC,KAAKR,EAAM,aASdjB,GAEHc,ME7CAY,EAAiB,CAC1B,OAAU,QACV,SAAY,CACR,OAAU,WACV,MAAS,CACL,CACI,OAAU,QACV,KAAQjF,EAAOC,SACf,MAAS,CACL,CACI,OAAU,OACV,KAAQ,MAIpB,CACI,OAAU,QACV,KAAQD,EAAOI,KACf,MAAS,CACL,CACI,OAAU,OACV,KAAQ,S,wBClBhC,SAAS8E,EAAkBnD,GACvB,OAAOoD,kBAAQC,oBAAUrD,EAAKgC,OAAQ,QAO1C,SAASsB,EAAcvB,EAAsBwB,GAKzC,IAJA,IAAIC,EAAID,EAAQ,EACVE,EAAWC,kBAAQ3B,GACnB4B,EAAsB,GACxBC,EAAWH,EAASD,GACjBI,IACHD,EAAUE,KAAV,MAAAF,EAAS,YAASR,EAAkBS,KAC/BE,MAAMC,QAAQH,IAA8B,IAAjBA,EAASzB,MAIzCyB,EAAWH,IADXD,GAGJ,OAAOG,EAMX,SAASK,EAAUC,GAAmC,IAAjBC,EAAgB,uDAAH,EAC9C,MAAM,GAAN,OAAUD,GAAV,OAAqBC,GAQzB,SAASC,EAAmBC,GACxB,IADsD,EACtCA,EAAOpC,MAAM,cADyB,mBAE7C3C,EAF6C,KAEvC6E,EAFuC,KAGtD,MAAO,CAAEA,WAAYG,SAASH,GAAa7E,QA+BxC,IAAMiF,EAAmB,UA+GzB,SAASC,EAAeC,EAA8BP,EAAkBQ,GAC3E,IACIC,EAAgBF,EADLR,EAAUC,EAAUQ,IAEnC,IAAKC,GAAiBD,EAAiB,EAAG,CACtC,IAAME,EAAoB1F,OAAO2F,KAAKJ,GACjCK,QAAO,SAACT,GAAD,OAAYA,IAAWE,KAC9BnF,IAAIgF,GACJU,QAAO,gBAAGxF,EAAH,EAAGA,KAAH,OAAc4E,IAAa5E,KAClCF,KAAI,qBAAG+E,cACNY,EAAsBC,KAAKC,IAAL,MAAAD,KAAI,YAAQJ,IAExC,OAAOH,EADQR,EAAUC,EAAUa,IAGvC,OAAOJ,EAQX,IAAMO,EAA8BC,aAAW,SAACC,GAAD,OAjJ/C,SAAiCC,GAC7B,OAAOC,oBACHD,GACA,SAACE,GAAD,OAAuBxB,MAAMyB,KAAKD,GAAmBnG,IAAIgF,MA+I7DqB,CA5HJ,SAAyBL,GACrB,IAAMpD,EAAuB3B,cAAI+E,EAAQ,kBACnCM,EAAaxG,OAAO2F,KAAKO,EAAOO,QAAU,IAC1CN,EAA4B,eAAMd,EAAmB,IAAIqB,KAGzDC,GAAe9B,MAAMC,QAAQhC,GAC7B8D,EAAqBD,GAAqC,IAAtBH,EAAWK,OAE/CC,EAAiBjC,MAAMC,QAAQhC,IAA2B,IAAjBA,EAAM+D,OACrD,GAAID,GAAsBE,EACtB,OAAOX,EAGX,GAAIQ,EAAa,CACb,IAAMI,EAAiBP,EAAWtG,KAAI,SAAA8G,GAAC,gBAAOA,EAAP,QACvCb,EAAcd,GAAoB,IAAIqB,IAAIK,GAF7B,2BAGb,YAAwBA,EAAxB,+CAAwC,CAAC,IAA9BE,EAA6B,QACpCd,EAAcc,GAAa,IAAIP,IAAIK,IAJ1B,kFAMb,OAAOZ,EAIX,IAAMe,EAAa7C,EAAcvB,GAAQ,GAAG5C,IAAIiH,gBAAMpC,IACtDtE,EAAOJ,EAAU8F,EAAed,EAAkBqB,KAAMQ,GAExD,cAA8BlH,OAAOoH,QAAQtE,GAA7C,eAAqD,CAAC,IAAD,0BAAzCuE,EAAyC,KAAjCC,EAAiC,4BACjD,IADiD,IACjD,EADiD,iBACtCvG,EADsC,QAEvCuD,EAAQc,SAASiC,GACjBtB,OAAmBwB,IAAbxG,EAAKgF,IAAoByB,IAAWzG,EAAKgF,IAC/C7C,OAAmBqE,IAAbxG,EAAKmC,IAAoB,EAAInC,EAAKmC,IAC9C,GAAI6C,EAAM7C,EACN,MAAM,IAAIuE,MAAJ,wBAA2BC,KAAKC,UAAU5G,GAA1C,MAGV,IlB3FiBL,EkB2FXkH,EAAa1D,EAAkBnD,GAEjCkE,EAAa,EACX4C,EAA6B,SAACC,GAAD,OAAuB/C,EAAU+C,EAAW7C,IACzE8C,EAA0B,SAACD,GAAD,OAAuB/C,EAAU+C,EAAW7C,EAAa,IACnFP,EAAYL,EAAcvB,EAAOwB,GAAOpE,IAAIiH,gBAAMpC,IAExD,GAAI7B,EAAM,EAAG,CAAC,IAAD,uBACT,YAAwB0E,EAAxB,+CAAoC,CAAC,IAC3BzC,EAASJ,EADiB,SAE1BiD,EAAc3H,EAAU8F,EAAehB,EAAQuB,KAErD,GADAjG,EAAOuH,EAAatD,GAChBqB,IAAQyB,IAER/G,EAAOuH,EADSJ,EAAW1H,IAAI6E,KAN9B,wFAWT,KAAOE,EAAa/B,GAAK,CAAC,IAAD,uBACrB,YAAwB0E,EAAxB,+CAAoC,CAAC,IAC7BzC,EAASJ,EADmB,QACEE,GAC5B+C,EAAc3H,EAAU8F,EAAehB,EAAQuB,KACrD,GAAIzB,IAAe/B,EAAM,EAErBzC,EAAOuH,EADSJ,EAAW1H,IAAI2H,IAE/BpH,EAAOuH,EAAatD,QAGpBjE,EAAOuH,EADSJ,EAAW1H,IAAI6H,KATlB,kFAcrB9C,IAIR,GAAIc,IAAQyB,IAER,IADAvC,EAAa/B,EAAM,EAAI,EAAIA,EAAM,EAC1B+B,EAAac,GAAK,CAAC,IAAD,uBACrB,YAAwB6B,EAAxB,+CAAoC,CAAC,IAC7BzC,EAASJ,EADmB,QACEE,GAC5B+C,EAAc3H,EAAU8F,EAAehB,EAAQuB,KAErD,GADAjG,EAAOuH,EAAatD,GAChBO,IAAec,EAAM,EAAG,CAExBtF,EAAOuH,EADSJ,EAAW1H,IAAI6H,QAE5B,CACH,IAAME,EAAUL,EAAW1H,IAAI2H,GlB1I9BnH,EkB2ISsH,EAAaC,ElB1IzCrH,QAAQF,EAAIwH,OAAQxH,KkBgIW,kFAarBuE,MA3DZ,EAAmBb,oBAAUkD,GAA7B,+CAAsC,IADW,mFAiErD,OAAOnB,EAgCiBgC,CAAgBjC,OAyCrC,I,EAAMkC,EAA4BnC,aA9BzC,SAA2BC,EAA0BmC,EAAoB/D,GACrE,IAAMiB,EAAQS,EAA4BE,GACtCT,EAAgBF,EAAMF,IAAqB,GAE3CiD,EAAe,EACfC,EAAeF,EAASvF,MAAM3B,IAAImH,GACtC,GAAIC,aAAwBC,IACxB,MAAO,GAKX,IAFA,IAAIC,EAAc,CAAExD,WAAY,EAAG7E,KAAMmI,EAAanI,MAE/CqF,EAAcoB,QAAU0B,GAAgBD,EAAehE,GAC1DmB,EAAgBH,EAAeC,EAAOkD,EAAYrI,KAAMqI,EAAYxD,YAEpEqD,IACAG,EAAYxD,cACZsD,EAAeF,EAASvF,MAAM3B,IAAImH,cACJE,KAASC,EAAYrI,OAASmI,EAAanI,OACrEqI,EAAc,CAAExD,WAAY,EAAG7E,KAAMmI,EAAanI,OAI1D,OAAOqF,EAAcvF,KAAI,qBAAGE,WCxLzB,IAAMsI,GAAS,CAClBjC,QAAM,mBACDzH,EAAOC,SZtDe,CAE3B4C,OAAQ,QACRC,MAAO,KYkDD,cAED9C,EAAOE,MXvDY,CACxB4C,MAAO,KWoDD,cAGD9C,EAAOG,SVxDe,CAC3B2C,MAAO,KUoDD,cAID9C,EAAOI,KAAOwC,GAJb,cAKD5C,EAAOK,cAAgB8D,GALtB,cAMDnE,EAAOM,YAAc2D,GANpB,cAODjE,EAAOO,SAAWsD,GAPjB,cAQD7D,EAAOQ,aT7DmB,CAC/BsC,MAAO,GACPgB,MAAO,CAAC,CAAEC,MAAO,CAAEC,OAAQ,YSmDrB,cASDhE,EAAOS,MAAQsC,GATd,GAWNsG,SAAU,CACNvF,MAAO,CACH,CACIC,MAAO,CAAE3C,KAAMpB,EAAOC,UACtBiE,IAAK,EACL6C,IAAK,GAET,CACIhD,MAAO,CACH,CAAE3C,KAAMpB,EAAOI,MACf,CAAEgB,KAAMpB,EAAOE,OACf,CAAEkB,KAAMpB,EAAOG,UACf,CAAEiB,KAAMpB,EAAOQ,cACf,CAAEY,KAAMpB,EAAOK,eACf,CAAEe,KAAMpB,EAAOM,aACf,CAAEc,KAAMpB,EAAOS,QAEnByD,IAAK,IAGbyF,UA3DR,SAAmBC,EAAgBC,GAAuB,IAC9CC,EAA6BD,EAA7BC,KAAM/H,EAAuB8H,EAAvB9H,KAAMgI,EAAiBF,EAAjBE,MAAOzE,EAAUuE,EAAVvE,MAC3B,GAAoB,aAAhBvD,EAAKiC,OACL,OAAO4F,EAEX,IACMI,EADiBZ,EAA0BQ,EAAOzG,MAAM+D,OAASnF,EAAMuD,GACpC,GAEzC,OAAQwE,GACJ,IAAK,oBAED,GADiB/H,EAAK+B,MAAM3B,IAAImD,EAAQ,GAC3B2E,KAAM,CACf,IAAMC,EAAQC,IAAMC,OAAO,CAAEhJ,KAAM4I,EAAmBlG,MAAO,CAAC0F,IAAKY,OAAO,CAAEH,KAAMF,EAAME,UACxF,OAAOL,EAAOS,gBAAgBtI,EAAKT,IAAKgE,EAAO4E,GAE/C,OAAON,EAAOU,6BAA6BC,WAAWR,EAAME,MAGpE,IAAK,oBACD,IAAMC,EAAQC,IAAMC,OAAO,CAAEhJ,KAAM4I,IACnC,OAAOJ,EAAOS,gBAAgBtI,EAAKT,IAAKgE,EAAO4E,GAEnD,QACI,UAsCRM,QAAQ,eACH9J,EAAe6D,IC7ExB,SAASkG,GAAYtJ,GACjB,OAAIA,aAAgBuJ,IACTvJ,EAAKC,KACW,kBAATD,EACPA,EAEJ,KAuCJ,IAAMwJ,GAAmBC,iBAAM,SAACC,EAAY9I,GAC/C,OAAIA,aAAgB+I,IACT3I,cAAI0I,EAAO,CAAC,SAAU,UAAW9I,EAAKX,OAE7C,SAAUW,EACHI,cAAI0I,EAAO,CAAC,SAAU,SAAU9I,EAAKX,YADhD,KCxDS2J,GAAY,UADH,OACG,iBACZC,GAAmB,UAFV,OAEU,wBACnBC,GAAgB,UAHP,OAGO,qBAChBC,GAAmB,UAJV,OAIU,wBACnBC,GAA4B,UALnB,OAKmB,iCASrCvB,GAAwB,KA2BtBwB,GAAgB,SAACP,EAAYrJ,GAC/B,IAAMsC,EAAQtC,EAAM6H,SAASvF,MACvBuH,EAAWvH,EAAM3B,IAAI2B,EAAMwH,KAAO,GAClCC,EAAiBF,GAAYV,GAAiBE,EAAOQ,GAC3D,OAAIE,GAAkBA,EAAevI,OAE1BxB,EAAMgK,MACT,CAAC,WAAY,SACb1H,EAAM8B,KAAKuE,IAAMC,OAAO,CACpBhJ,KAAMpB,EAAOI,SAKlBoB,GAeJ,IAOMiK,GAAW,SAAC,GAAD,IAAGjK,EAAH,EAAGA,MAAOkK,EAAV,EAAUA,WAAV,OAA2E,SAACC,EAAoBC,GAEpH,IAAMf,EAAQe,IACdD,EAAS,CACLvK,KAAM2J,GACNvJ,MAAO4J,GAAcP,EAAOrJ,GAC5BkK,eAGJ,IAAMG,EA3BV,SAA6BrK,GACzB,GAAKA,EAAMsK,WAAX,CAGA,IAAMC,EAAiBvK,EAAM6H,SAAS2C,QAAQxK,EAAMsK,YACpD,GAAKC,EAGL,OAAOA,EAAe5J,IAAI,IAmBD8J,CAAoBzK,QACpB+G,IAArBsD,GACAF,EAASO,GAAoBL,IAI7BH,GAAcA,EAAWS,MAAK,kBAAuB,kBAAvB,EAAG/K,SACjCgL,GAAwBT,KAK1BU,GAAgB,kBAAM,SAACV,EAAoBC,GACxCA,IAAWU,SAASC,QAGzBZ,EAAS,CACLvK,KAAM6J,GACNsB,QAAQ,MAKHC,GAAiB,kBAAM,SAACb,EAAoBC,GACrD,IAAMf,EAAQe,IAGd,GDrHG,SAA0Bf,GAAa,IAClCrJ,EAAUqJ,EAAVrJ,MACAiL,EAAwBjL,EAAxBiL,SAAUC,EAAclL,EAAdkL,UAElB,OAAQA,EAAUC,YAAcD,EAAUE,aAAeH,EAASxC,KCgH/C4C,CAAiBhC,GACpC,CAKA,IAAMiC,EDlGH,SAAqCjC,GAAa,IAAD,EAClCA,EAAVrJ,MACAkL,EAF4C,EAE5CA,UAIFK,EAN8C,EAEjC1D,SAEgB2D,qBAAqBN,GAGnDxL,IAAIyJ,GAAiBE,IACrB3J,KAAI,SAACgG,GAAD,OAAYA,GAAUA,EAAOpE,SACjC8D,OAAOqG,SACP/L,KAAI,SAAC4B,GAAD,OAAWA,EAAO5B,IAAIuJ,OAC1ByC,OACCJ,EAAgBK,eAAY,WAAZ,cAAgBJ,IACtC,IAAIK,kBAAQN,GAGZ,OAAOA,ECkFeO,CAA4BxC,GAClD,GAAKiC,EAAL,CAKA,IAyBeQ,EAAcC,EAzBvBC,EDlFH,WACH,IAAMd,EAAY3H,OAAO0I,eACzB,GAAIf,GAAaA,EAAUgB,WAAa,EACpC,OAAOhB,EAAUiB,WAAW,GAAGC,wBC+EbC,GACtB,GAwBeP,EAxBDE,EAwBeD,EAxBA1C,EAAMyB,SAASkB,gBAyBrCF,IAAUC,GACTD,GAASC,GACND,EAAMQ,IAAMP,EAAMO,GAClBR,EAAMS,IAAMR,EAAMQ,GAClBT,EAAMU,SAAWT,EAAMS,QACvBV,EAAMW,QAAUV,EAAMU,OA3BjCtC,EAAS,CACLvK,KAAM6J,GACNsB,QAAQ,EACRiB,gBACAV,uBAZAnB,EAASU,WANTV,EAASU,QAuBXD,GAA0B8B,oBAAS,SAACvC,GACtC,OAAOA,EAASa,QACjB,GAoBI,IAAMN,GAAsB,SAACL,GAAD,OAA8B,SAACF,EAAoBC,GAC9EA,IAAWC,mBAAqBA,GAGpCF,EAAS,CAAEvK,KAAM4J,GAAqBa,uBAI7BsC,GAAmB,SAAC5B,GAAD,OAAqB,SAACZ,EAAoBC,GAClEA,IAAWwC,kBAAoB7B,IAG/BA,GACAZ,EAASU,MAEbV,EAAS,CAAEvK,KAAM8J,GAAqBqB,cAI7B8B,GAA2B,SAAC9B,GAAD,OAAqB,SAACZ,EAAoBC,GAC1EA,IAAW0C,0BAA4B/B,GAG3CZ,EAAS,CAAEvK,KAAM+J,GAA8BoB,aAItCgC,GAAmB,SAACjM,EAAckM,GAAf,OAAuC,SAAC7C,EAAoBC,GAAwB,IAAD,EAC3EA,IAA5BpK,EADuG,EACvGA,MAAOqK,EADgG,EAChGA,iBACW,kBAAf2C,IACPA,EAAa3C,GAES,kBAAf2C,GAIX7C,EAASF,GAAS,CACdjK,MAAOA,EAAMgK,MAAM,CAAC,WAAY,QAASgD,EAAY,OAAQ,SAAUlM,QAmBzEmM,GAAU,SAAC1M,GAAD,OAA+BA,aAAgBoI,KAEzDuE,GAAS,SAAC3M,GACZ,OAAO/B,EAAOK,gBAAkB0B,GAAQ/B,EAAOM,cAAgByB,GAGnE,SAAS4M,GAAW7K,EAAmBwB,EAAelE,GAClD,IAAMW,EAAO+B,EAAM3B,IAAImD,GACvB,IAAKmJ,GAAQ1M,GACT,OAAO+B,EAGX,GAAI4K,GAAO3M,EAAKX,QAAUsN,GAAOtN,GAAO,CAEpC,IAAMwN,EAAa7M,EAAK+B,MAAM8C,OAAO6H,IAASvN,KAAI,SAACa,GAAD,OAC9CA,EAAML,IAAI,OAAQN,GACbM,IAAI,OAAQmN,IAAKzE,OAAO,QAEjC,OAAOtG,EAAMgL,OAAN,MAAAhL,EAAK,CAAQwB,EAAO,GAAf,mBAAqBsJ,EAAWG,aAGhD,IAAKL,GAAO3M,EAAKX,OAASsN,GAAOtN,GAAO,CAEpC,IAAM4N,EAAWjN,EAAKL,IAAI,OAAQ1B,EAAOO,UACpCmB,IAAI,OAAQmN,IAAKzE,OAAO,KACvB6E,EAAWC,eAAK,CAACF,IACvB,OAAOlL,EAAMpC,IACT4D,EAEA6E,IAAMC,OAAO,CACThJ,OACAgB,KAAMyM,IAAKzE,OAAO,IAClBtG,MAAOmL,KAMnB,OAAOnL,EAAMpC,IACT4D,EACAvD,EAAML,IAAI,OAAQN,GACbM,IAAI,OAAQmN,IAAKzE,OAAO,MAI9B,IAAM+E,GAAkB,SAAC/N,GAAD,OAAkB,SAACuK,EAAoBC,GAAwB,IAAD,EACrDA,IAA5BpK,EADiF,EACjFA,MAAOqK,EAD0E,EAC1EA,iBACiB,kBAArBA,GAIXF,EAASF,GAAS,CACdjK,MAAOA,EAAMgK,MAAM,CAAC,WAAY,SAAUmD,GAAWnN,EAAM6H,SAASvF,MAAO+H,EAAkBzK,SAKxFgO,GAAc,SAACZ,EAAqB/N,GAAtB,OAAyC,SAACkL,EAAoBC,GACrF,IAAMf,EAAQe,IACNpK,EAAUqJ,EAAVrJ,MACR,GAA0B,kBAAfgN,EAAX,CAGA,IAAMa,EAAc1E,GAAiBE,EAAO,CAAEzJ,KAAMpB,EAAOS,QACrD6O,EAAanF,IAAMC,OAAO,CAC5BhI,KAAMyM,IAAKzE,OAAO,CACd9H,MAAOH,cAAIkN,EAAa,sBACxB3M,UAAWP,cAAIkN,EAAa,0BAC5BpM,IAAKxC,IAETW,KAAMpB,EAAOS,QAGXqD,EAAQtC,EAAM6H,SAASvF,MACvB/B,EAAO+B,EAAM3B,IAAIqM,GACjBvM,EAAc0I,GAAiBE,EAAO9I,GACtCkN,EAAalN,EAAKkI,OAAShI,GAAgBA,EAAYe,OAEvDc,EAAMyL,OAAOf,EAAa,EAAGc,GAD7BxL,EAAMpC,IAAI8M,EAAYc,GAG5B3D,EAASF,GAAS,CACdjK,MAAOA,EAAMgK,MACT,CAAC,WAAY,SACbyD,SCpSNO,GAAWC,iBAAO,CACpBlD,QAAQ,EACRO,mBAAevE,EACfiF,mBAAejF,IAGbmH,GAAgBD,iBAAO,CACzBjO,MAAOmO,IAAMC,SACTlH,KAAKmH,MAAMC,aAAaC,QAVN,UAUoCrH,KAAKC,UAAU1D,KAEzEiC,OAAQwC,GACRmC,sBAAkBtD,EAClB6F,iBAAiB,EACjBE,yBAAyB,EACzBhC,SAAUkD,MARQC,G,iFCpBTO,GAAmB,CAAC,MAAO,MAAO,OAAQ,OAC1CC,GAAcD,GAAiB9O,KAAI,SAACgP,GAAD,sBAAkBA,MAIrDC,GAAgB,SAACC,GAAD,OAAgB,IAAIC,SAAgB,SAACC,EAASC,GACvE,IAAMC,EAAS,IAAIC,WACnBD,EAAOE,OAAS,SAACC,GACbA,EAAEC,QAAUN,EAAQK,EAAEC,OAAOC,SAEjCL,EAAOM,QAAUP,EACjBC,EAAOL,cAAcC,O,SCEnBW,I,OAAK,qBACNpQ,EAAMC,KAAOoQ,MADP,eAENrQ,EAAME,OAASoQ,MAFT,eAGNtQ,EAAMG,WAAaoQ,MAHb,IAeLC,GAAa,SAAC,GAAD,IAAGC,EAAH,EAAGA,SAAUC,EAAb,EAAaA,WAAYC,EAAzB,EAAyBA,aAAzB,OACf,kBAAC,aAAD,CACIC,MAAOC,eAAaC,MACpBC,SAAUC,WAASC,IACnBC,KAAMd,GAAMK,IAAaJ,KACzBK,WAAYA,EACZS,YAAa,SAACC,GACVA,EAAMlN,iBACNyM,EAAaF,OCTnBY,GAAqB,CACvBC,WJiBsB,kBAAM,WAC5BrI,GAAQsI,aAAaxR,KIjBrByR,WJMsB,SAAC3N,GAAD,OAAkB,WACxCoF,GAAQwI,WAAW,CACfhR,KAAMV,EACN0B,KAAM,CAAEoC,UAGZoF,GAAQyI,cIXRf,aJAiC,SAACF,GAAD,OAAsB,WACvDxH,GAAQ0I,WAAWlB,MIEjBmB,GAAYC,aAzBM,SAAC3H,GAAgB,IAC7BrJ,EAAoBqJ,EAApBrJ,MAAO8K,EAAazB,EAAbyB,SACTmG,EAAYjR,EAAgBgJ,QAAQ2B,MAAK,SAACuG,GAAD,OAAqBzF,QAAQyF,GAAUA,EAAOtR,OAASV,MAE/EiS,EAA8BrG,EAA7CkB,cAA2BV,EAAkBR,EAAlBQ,cAE7BhK,GAAS2P,EACTG,kBAAQ9F,EAAenM,EAAMG,YAC7BgM,IAAkB,GAGxB,MAAO,CACH+F,YAHgB/F,GAAiBtL,EAAMqR,YAAY3F,OAInDuF,WACAE,aACA7P,WAUmCkP,GAAzBQ,EDoBD,SAAC,GAAgG,IAA9FG,EAA6F,EAA7FA,WAAYE,EAAiF,EAAjFA,YAAa/P,EAAoE,EAApEA,MAAOwO,EAA6D,EAA7DA,aAAcmB,EAA+C,EAA/CA,SAAUN,EAAqC,EAArCA,WAAYF,EAAyB,EAAzBA,WAC9Ea,EAAaC,iBAAO,MADmF,EEjB1G,SACHrQ,EACAiQ,EACAG,EACAE,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,GACD,IAAD,EACoCC,mBAAS,CAAEC,QAAS,OADxD,mBACSC,EADT,KACoBC,EADpB,KAME,OAJAC,qBAAU,WACND,EAAa,CAAEF,QAAS,CAAE5F,sBAAuB,kBAAM+E,QACxD,CAACA,IAEGiB,UAAQC,mBACXnR,EACA+Q,EACAX,EACAE,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,GFRoCQ,CACpCC,YAAUC,OACVrB,EACAG,GACA,EACA,CAAEmB,SAAU,IALRC,EAFqG,EAErGA,iBAAkBlB,EAFmF,EAEnFA,UAU1B,OACI,kBAAC,UAAD,CACIA,UAAWA,EACX5P,UAAU,uBACV+Q,YAAaD,EACbpB,WAAYA,GAEXhQ,EAAM5B,KAAI,SAACkQ,GAAD,OACP,kBAAC,GAAD,CACI9P,IAAK8P,EACLA,SAAUA,EACVC,YAbIjQ,EAamBgQ,EAbFnE,QAAQ4F,EAAYuB,MAAK,SAAAC,GAAC,OAAIA,EAAEjT,OAASA,OAc9DkQ,aAAcA,IAdX,IAAClQ,MAiBVgM,kBAAQtK,IAAU,yBAAKM,UAAU,kCACnC,kBAAC,aAAD,CACImO,MAAOC,eAAaC,MACpBC,SAAUC,WAASC,IACnBC,KAAMyC,KACNjD,WAAYoB,EACZX,YAAa,SAACC,GAEV,GADAA,EAAMlN,iBACF4N,EACAR,QACG,CAEH,IAAMzN,EAAO+P,OAAO,8BAChB/P,GACA2N,EAAW3N,W,qBGtFjCgQ,I,OAAM,qBACPxU,EAAOI,KAAO,aADP,eAEPJ,EAAOC,SAAW,YAFX,eAGPD,EAAOE,MAAQ,SAHR,eAIPF,EAAOG,SAAW,YAJX,eAKPH,EAAOQ,aAAe,gBALf,IAWNiU,GAAe,SAAC,GAAgC,IAA9BrT,EAA6B,EAA7BA,KACdsT,EAAiBtQ,EAAiBhD,GACxC,OAAO,kBAACsT,EAAD,CAAgB3S,KAAM,CAAEX,SAAkBoT,GAAOpT,KCXtD4Q,GAAqB,CACvB3D,4BACAc,oBAGEoD,GAAYC,aAXM,SAAC3H,GACrB,MAAO,CACHyD,wBAAyBzD,EAAMyD,2BASI0D,GAAzBQ,EDoBiC,SAACrP,GAAW,IAEvD8E,EAMA9E,EANA8E,UACA0M,EAKAxR,EALAwR,UACAxF,EAIAhM,EAJAgM,gBACAyF,EAGAzR,EAHAyR,mBACAtG,EAEAnL,EAFAmL,wBACAD,EACAlL,EADAkL,yBAGJ,OACI,kBAAC,WAAD,CACIjL,UAAU,cACVqQ,UAAWkB,EACXE,cAAezH,kBAAQwH,IAAuBtG,EAC9CwG,QAAS,kBAAMxG,GAA2BD,GAAyB,KAEnE,kBAAC,OAAD,KACKuG,EAAmB1T,KAAI,SAACE,GACrB,IAAMsD,EAAU,kBAAMyK,EAAgB/N,IACtC,OACI,kBAAC,WAAD,CACI2T,aAAW,EACXzT,IAAKF,EACLiQ,WAAYjQ,IAAS6G,EACrBvD,QAASA,EACTsQ,aAActQ,GAEd,kBAAC,GAAD,CAActD,KAAMA,aE9C1C6T,IAAW,qBACZlV,EAAMmV,OAASC,MADH,eAEZpV,EAAM0C,KAAO2S,MAFD,eAGZrV,EAAMsV,MAAQC,MAHF,IAKXC,IAAgB,qBACjBvV,EAAOK,cAAgBmV,MADN,eAEjBxV,EAAOM,YAAcmV,MAFJ,IAIhBC,GAAqB,CAAC1V,EAAOI,KAAMJ,EAAOC,SAAUD,EAAOE,MAAOF,EAAOG,SAAUH,EAAOQ,cAC1FmV,GAAiB,CAAC3V,EAAOK,cAAeL,EAAOM,aCN/C0R,GAAqB,CACvBzD,oBACAY,mBACAd,6BAGEkE,GAAYC,aArBM,SAAC3H,GAAgB,IAC7BrJ,EAAqDqJ,EAArDrJ,MAAOqK,EAA8ChB,EAA9CgB,iBAAkByC,EAA4BzD,EAA5ByD,wBAC3BsH,EAAa/J,GAAoBrK,EAAMqU,MAAM,CAAC,WAAY,QAAShK,IAKzE,MAAO,CACHA,mBACAiK,WALehU,EAAY8T,EAAY,QADvBjL,GAAiBE,EAAO+K,IAOxC3N,UALc2N,GAAcA,EAAWxU,KAMvCkN,6BAUmC0D,GAAzBQ,EDkBkB,SAACrP,GAAW,IAExC0I,EAUA1I,EAVA0I,iBACA4H,EASAtQ,EATAsQ,UACAlF,EAQApL,EARAoL,iBACAuH,EAOA3S,EAPA2S,WACAC,EAMA5S,EANA4S,qBACA5G,EAKAhM,EALAgM,gBACAlH,EAIA9E,EAJA8E,UACA+N,EAGA7S,EAHA6S,mBACA3H,EAEAlL,EAFAkL,yBACAC,EACAnL,EADAmL,wBAEEwE,EAAaC,iBAAO,MAbiB,EAcUa,UAAQC,mBACzDE,YAAUkC,aACVxC,EACAX,GACA,OACAvK,GACA,GACA,GACA,EACA,CAACsD,EAAkB4H,IATGU,EAdiB,EAcnCD,iBAA+BlB,EAdI,EAcJA,UAYjCkD,EAAoB,kBAAM7H,GAA0BC,IAEpDsG,EAAqBzH,uBAAauI,GAAoBM,GACtDG,EAAiBhJ,uBAAawI,GAAgBK,GAC9CrB,EAAY5B,iBAAO,MAGnBpE,EAAa,SAACvN,GAAD,OAAkB,kBAAM+N,EAAgB/N,KAE3D,OACI,oCACKkN,GACG,kBAAC,GAAD,CACIqG,UAAWA,EACX1M,UAAWA,EACX2M,mBAAoBA,IAG5B,kBAAC,UAAD,CACI5B,UAAWA,EACX5P,UAAU,cACVgT,UAAW,EACXtD,WAAYA,EACZqB,YAAaA,GAEb,yBAAK/Q,UAAU,6CACV2S,EAAqB7U,KAAI,SAACoB,GACvB,IAAMoC,EAAU,kBAAM6J,EAAiBjM,IACvC,OACI,kBAAC,aAAD,CACIhB,IAAKgB,EACLiP,MAAOC,eAAaC,MACpBC,SAAUC,WAASC,IACnBP,WAAYyE,IAAexT,EAC3BuP,KAAMoD,GAAY3S,GAClBoC,QAASA,EACTsQ,aAActQ,QAKxB0I,kBAAQwH,IACN,kBAAC,SAAD,CACID,UAAWA,EACXpD,MAAOC,eAAaC,MACpBC,SAAUC,WAASC,IACnByE,SAAUC,KACVC,UAAWC,KACX9R,QAASwR,EACTlB,aAAckB,IAIrBC,EAAejV,KAAI,SAACE,GAAD,OAChB,kBAAC,aAAD,CACIE,IAAKF,EACLmQ,MAAOC,eAAaC,MACpBC,SAAUC,WAASC,IACnBP,WAAYpJ,IAAc7G,EAC1ByQ,KAAM0D,GAAiBnU,GACvBsD,QAASiK,EAAWvN,cEzHnCqV,GAA+B,SAACtT,GAAW,IAEhDuT,EAGAvT,EAHAuT,aACAjL,EAEAtI,EAFAsI,SACGlI,EAJ4C,YAK/CJ,EAL+C,6BAO7CwT,EAAgB,yCAAG,kCAAAC,EAAA,2DAAShG,EAAT,EAASA,QACnBiG,MADU,uBRdAA,EQgBW,YAAIjG,EAAOiG,OAAjCC,ERhB6BD,EAAMjQ,QAAO,SAACwJ,GAAD,OAAUH,GAAY8G,SAAS3G,EAAKhP,SQcnE,SAGMiP,QAAQ2G,IAC3BF,EAAO5V,IAAIiP,KAJE,OAGX8G,EAHW,OAMjBxL,EAASwL,GANQ,iCRdD,IAACJ,IQcA,OAAH,sDAUtB,OACI,yCACIpT,IAAKiT,EACLQ,OAAQjH,GAAYkH,KAAM,MAC1B/V,KAAK,OACLqK,SAAUkL,GACNpT,KCtBVyO,GAAqB,CACvB7D,oBACAiB,gBAGEmD,GAAYC,aAZM,SAAC3H,GACrB,MAAO,CACHgB,iBAAkBhB,EAAMgB,iBACxBuC,gBAAiBvD,EAAMuD,mBASY4D,GAAzBQ,ECDQ,SAAC,GAA6F,IAA3FiB,EAA0F,EAA1FA,UAAWrF,EAA+E,EAA/EA,gBAAiBD,EAA8D,EAA9DA,iBAAkBtC,EAA4C,EAA5CA,iBAAkBuD,EAA0B,EAA1BA,YACnFsH,EAAsC3D,iBAAO,MAC7CqE,EAAc,WAChBV,EAAalD,SAAWkD,EAAalD,QAAQ6D,SAIjD,OACI,kBAAC,WAAD,CACIxC,cAAY,EACZpB,UAAWA,EACXqB,QAAS,kBAAM1G,GAAmBD,GAAiB,KAEnD,kBAAC,GAAD,CACIuI,aAAcA,EACdY,MAAO,CAAEC,QAAS,QAClB9L,SAXY,SAACwL,GAAD,OAAwBA,EAAS/V,KAAI,SAACsW,GAAD,OAAapI,EAAYvD,EAAkB2L,SAahG,kBAAC,OAAD,KACI,kBAAC,WAAD,CACIzC,aAAW,EACX1D,YAAY,EACZoG,OAAQ,kBAAC,OAAD,CAAM5F,KAAM6F,KAAUpM,KAAMqM,OAAKC,IACzCtM,KAAMuM,eAAaC,KACnBpT,QAAS0S,EACTpC,aAAcoC,GANlB,cCHVpF,GAAqB,CACvB7D,qBAGEoE,GAAYC,aA3BM,SAAC3H,GAAgB,IAC7BrJ,EAAoCqJ,EAApCrJ,MAAO0F,EAA6B2D,EAA7B3D,OAAQ2E,EAAqBhB,EAArBgB,iBACjB+J,EAAa/J,GAAoBrK,EAAMqU,MAAM,CAAC,WAAY,QAAShK,IACnE5D,EAAY2N,GAAcA,EAAWxU,KACrCa,EAAc2T,GAAcjL,GAAiBE,EAAO+K,GAEpDI,EAAsB/T,IAAgBA,EAAYe,OAClDoG,EAA0BlC,EAAQ1F,EAAM6H,SAAUwC,GAClD,GAMN,MAAO,CACH5D,YACA8N,qBAN0BH,GAAczT,cAAIF,EAAa,CAAC,OAAQ,UAAYjB,OAAO2F,KAAK5G,GAAS,GAOnGiW,qBACA+B,WANa9K,QAAQ2I,IAAeA,EAAW3L,MAAQhI,IAAgBA,EAAYe,QAOnFoL,gBAAiBvD,EAAMuD,mBAQY4D,GAAzBQ,ECd2B,SAACrP,GAAW,IAEjD8E,EAQA9E,EARA8E,UACA0M,EAOAxR,EAPAwR,UACAoB,EAMA5S,EANA4S,qBACAC,EAKA7S,EALA6S,mBACA+B,EAIA5U,EAJA4U,WACA3J,EAGAjL,EAHAiL,gBACAD,EAEAhL,EAFAgL,iBACA6J,EACA7U,EADA6U,WAGEtT,EAAU,SAACC,GACbwJ,GAAkBC,GAClBzJ,EAAIE,iBACJF,EAAIG,mBAEFmT,EAAkBhL,QAAQ8I,EAAqBlO,QAC/CqQ,EAAsBlC,EAAmBnO,OAAS,GACtB,IAA9BmO,EAAmBnO,QAAgBmO,EAAmB,KAAO/N,EAE3DkQ,EAAwBH,IAAeC,GAAmBC,GAEhE,OACI,oCACKC,GACD/J,IACI2J,EACM,kBAAC,GAAD,CAAYtE,UAAWkB,IACvB,kBAAC,GAAD,CACElB,UAAWkB,EACXoB,qBAAsBA,EACtBC,mBAAoBA,KAGhC,kBAAC,aAAD,CACIrB,UAAWA,EACXjD,SAAUC,WAASyG,OACnBvG,KAAMkG,EAAaM,KAAUC,KAC7BhN,KAAMqM,OAAKtD,EACXiD,MAAO,CAAEiB,WAAYJ,EAAwB,UAAY,UACzDzT,QAASA,EACTsQ,aAActQ,Q,OC1BvB,I,GCbDsN,GAAqB,CACvB9F,wBAGEqG,GAAYC,aArBM,SAAC3H,EAAY2N,GAAmB,IAC5C3M,EAA6ChB,EAA7CgB,iBAAkBuC,EAA2BvD,EAA3BuD,gBAAiB5M,EAAUqJ,EAAVrJ,MACnCO,EAASyW,EAATzW,KAEFE,EAAc0I,GAAiBE,EAAO9I,GACtC0W,EAAcxL,QAAQhL,GAAeA,EAAYe,QAIvD,MAAO,CACH6I,iBAAkBA,EAClB6M,UAJclX,EAAM6H,SAAS2C,QAAQjK,GAKrC0W,cACArK,gBAAiBA,KAQkB4D,GAAzBQ,EDS4B,SAACrP,GAAW,IAElD0I,EAQA1I,EARA0I,iBACA6M,EAOAvV,EAPAuV,UACAC,EAMAxV,EANAwV,SACAtU,EAKAlB,EALAkB,SACA+J,EAIAjL,EAJAiL,gBACAqK,EAGAtV,EAHAsV,YACA1W,EAEAoB,EAFApB,KACAmK,EACA/I,EADA+I,oBAEEyI,EAAY5B,iBAAO,MACnBuE,EArCV,SAAqCqB,EAAkChE,EAAyC5S,GAAa,IAAD,EAC9FwR,mBAAS,IADqF,mBACjH+D,EADiH,KAC1GsB,EAD0G,KAUxH,OARAjF,qBAAU,WACN,IAAMkF,EAAkBF,GAAYA,EAASnF,SAAWsF,KAAWH,EAASnF,SACtEuF,EAAepE,GAAaA,EAAUnB,SAAWmB,EAAUnB,QAAQ5F,wBAAwBI,OACjG4K,EAAS,CAELI,MAAOD,GAAgB,EAAIF,GAAmB,MAEnD,CAACF,EAAUhE,EAAW5S,IAClBuV,EA2BO2B,CAA4BN,EAAUhE,EAAW5S,GACzDmX,EAAcR,GAAgC,IAAnBA,EAAUpN,KAErCkD,EAAakK,GAAaA,EAAUS,QAMpCC,EAAgBvN,IAAqB2C,EAE3C,OAAO0K,EAEC,yBACI9V,UAAU,uBACViW,aAXS,WACZjL,GACDlC,EAAoBsC,MAWdiK,GACE,yBAAKrV,UAAU,oCAAoCO,iBAAiB,EAAO2T,MAAOA,GAC9E,kBAAC,GAAD,CAAa3C,UAAWA,EAAWqD,WAAYoB,KAGtD/U,GAGPA,K,OErDV,IAAMmQ,IAAM,qBACPzU,EAAMmV,OAAS,UADR,eAEPnV,EAAMsV,MAAQ,SAFP,eAGPtV,EAAM0C,KAAO,QAHN,eAIPJ,EAAeM,MAAQ,eAJhB,eAKPN,EAAeqQ,OAAS,cALjB,IA6GL,IC9GDV,GAAqB,CACvBsH,iBAAkB/K,GAClBgL,qBlB0LgC,SAAC7W,EAA2B8L,GAA5B,OAAoD,SAAC7C,EAAoBC,GACzG,GAA0B,kBAAf4C,EAAX,CADgI,IAIxHhN,EAAUoK,IAAVpK,MAERmK,EAASF,GAAS,CACdjK,MAAOA,EAAMgK,MAAM,CAAC,WAAY,QAASgD,EAAY,OAAQ,aAAc9L,MAG3EA,IAAcL,EAAeqQ,QAAUlR,EAAMqU,MAAM,CAAC,WAAY,QAASrH,EAAY,OAAQ,YAAczO,EAAMmV,QACjHvJ,EAAS4C,GAAiBxO,EAAM0C,KAAM+L,OkBpM1CgL,clBuD4B,kBAAM,SAAC7N,EAAoBC,GAAwB,IACvEpK,EAAUoK,IAAVpK,MACRmK,EAASF,GAAS,CACdjK,MAAOA,EAAME,IAAI,YAAa+X,IAAUrP,OAAO,WkBvDjDmI,GAAYC,aArBM,SAAC3H,EAAY2N,GAAmB,IAC5ChX,EAAUqJ,EAAVrJ,MACAO,EAASyW,EAATzW,KAEF2W,EAAYlX,EAAM6H,SAAS2C,QAAQjK,GAKzC,MAAO,CACHyM,WALekK,GAAaA,EAAUS,QAMtClX,YAJgB0I,GAAiBE,EAAO9I,MAcLiQ,GAAzBQ,EDwG6B,SAACrP,GAAW,IAEnDqL,EAQArL,EARAqL,WACAvM,EAOAkB,EAPAlB,YACAqX,EAMAnW,EANAmW,iBACAC,EAKApW,EALAoW,qBACAC,EAIArW,EAJAqW,cACAlW,EAGAH,EAHAG,SACAoW,EAEAvW,EAFAuW,cACA3X,EACAoB,EADApB,KAGE+Q,EAAaC,iBAAO,MAZ4B,EAaDa,UAAQC,mBACzDE,YAAU4F,MACVrW,EACAwP,EACA4G,OACAnR,EACAmR,GACA,GACA,EACA,CAACpW,EAAUvB,IATWoS,EAb4B,EAa9CD,iBAA+BlB,EAbe,EAafA,UAYjC4G,EAAiB7G,iBAAO,MAMxB8G,EAAiB/X,EAAYC,EAAM,YAAaE,GAChD6X,EAAahY,EAAYC,EAAM,QAASE,GACxC8X,EAAiBF,IAAmBxX,EAAeqQ,OACnD,CAAC3S,EAAM0C,KAAM1C,EAAMsV,OACnB,CAACtV,EAAM0C,KAAM1C,EAAMmV,OAAQnV,EAAMsV,OAEjC2E,EAzJV,SAAyB1W,GACrB,SAAIA,IAAYA,EAASkQ,UACdlQ,EAASkQ,QAAQyG,eAAiB3W,EAASkQ,QAAQ0G,YAuJjCC,CAAgB7W,GAC7C,OACI,kBAAC,UAAD,CACIF,UAAU,0CACV4P,UAAWA,EACXF,WAAYA,EACZqB,YAAaA,EACbiC,UAAW,EACXgE,UAAW,EACXtI,YApBY,SAACnN,GACjBA,EAAIG,kBACJH,EAAIE,mBAoBA,yBAAKzB,UAAU,kFACX,yBAAKA,UAAU,uCACX,yBAAKA,UAAU,sCAAf,iBACA,kBAAC,aAAD,CACIuR,UAAWiF,EACXxW,UAAU,qCACVyO,KAAMwI,KACN/O,KAAMqM,OAAKtD,EACXiG,MAAOC,QAAMC,KACb9I,SAAUC,WAASC,IACnBlN,QAAS8U,KA5JzB,oCACI,yBAAKpW,UAAU,yCAAf,QAGA,yBAAKA,UAAU,+CACX,kBAAC,SAAD,CACIiO,YAAU,EACVK,SAAUC,WAASyG,OACnBkC,MAAOC,QAAMC,MAHjB,gBAahB,SACIhM,EACAqL,EACAN,EACAS,GAEA,IAAMS,EAAmB,SAAC/X,GAAD,OAA+B,kBAAM6W,EAAqB7W,EAAW8L,KAExFkM,EAAe,SAAChY,GAAD,OACjB,kBAAC,SAAD,CACIiY,UAAWX,EACX3I,WAAYwI,IAAmBnX,EAC/BgP,SAAUC,WAASyG,OACnBkC,MAAOC,QAAMC,KACb9V,QAAS+V,EAAiB/X,IAEzB8R,GAAO9R,KAIhB,OACI,oCACI,yBAAKU,UAAU,yCAAf,iBAGA,yBAAKA,UAAU,+CACVsX,EAAarY,EAAeM,OAC5B+X,EAAarY,EAAeqQ,UAqH5BkI,CAAgBpM,EAAYqL,EAAgBN,EAAsBS,GA/GnF,SACIxL,EACAsL,EACAC,EACAT,EACAU,GAEA,IAAMa,EAAe,SAACvY,GAAD,OAAkB,kBAAMgX,EAAiBhX,EAAOkM,KAcrE,OACI,oCACI,yBAAKpL,UAAU,yCAAf,aAGA,yBAAKA,UAAU,+CACV2W,EAAe7Y,KAnBP,SAACoB,GAAD,OACjB,kBAAC,SAAD,CACIqY,UAAWX,EACX1Y,IAAKgB,EACL+O,WAAYyI,IAAexX,GAAUA,IAAUvC,EAAM0C,OAASsX,EAAehD,SAAS+C,GACtFpI,SAAUC,WAASyG,OACnBkC,MAAOC,QAAMC,KACb9V,QAASmW,EAAavY,IAErBkS,GAAOlS,SAgGHwY,CAAYtM,EAAYsL,EAAYC,EAAgBT,EAAkBU,QErLjFzH,I,OAAYC,aAZM,SAAC3H,EAAY2N,GAAmB,IAC5ChX,EAAUqJ,EAAVrJ,MACAO,EAASyW,EAATzW,KAGR,MAAO,CACHgZ,cAHkBvZ,EAAMkL,UAAUsO,WAAaxZ,EAAMsK,aAAe/J,KAOjD,GAETyQ,ECG2B,SAACrP,GAAW,IAEjDC,EAKAD,EALAC,UACA2X,EAIA5X,EAJA4X,cACA1X,EAGAF,EAHAE,WACAtB,EAEAoB,EAFApB,KACGwB,EAN6C,YAOhDJ,EAPgD,mDAQ9CG,EAAWyP,iBAAO,MAExB,OACI,oCACI,kBAAC,EAAD,eACI3P,UAAWM,IACPN,EACA2X,GAAiB,kCAErB1X,WAAYA,EACZC,SAAUA,EACVvB,KAAMA,GACFwB,IAER,kBAAC,GAAD,CACID,SAAUA,EACVoW,cAAeqB,EACfhZ,KAAMA,S,SCpChBkZ,GAAWrQ,iBAAM,SAACxJ,EAAcW,GAAf,OAClBA,aAAgBoI,KAASpI,aAAgB+I,MAAW/I,EAAKX,OAASA,KCevE,IAAM8Z,GAAa,SAAC/X,EAAwByG,EAAoBuR,GAA6B,IACjF9W,EAAmBlB,EAAnBkB,SAAUlD,EAASgC,EAAThC,KADsE,EAEzDgC,EAAMiY,WAA7B3X,EAFgF,EAEhFA,IAAQ2X,EAFwE,uBAIlF1Q,EAAOpG,EAAgBnD,EAAKC,MAClC,OAAIsJ,EACO,kBAACA,EAAD,eAAMrH,WAAYI,EAAKtC,KAAMA,GAAUia,GAAa/W,GAExD8W,KAMLE,GAAe,SAAClY,EAA0ByG,EAAoBuR,GAA6B,IACrF9W,EAAmBlB,EAAnBkB,SAAUtC,EAASoB,EAATpB,KAD0E,EAE7DoB,EAAMiY,WAA7B3X,EAFoF,EAEpFA,IAAQ2X,EAF4E,uBAItFtQ,EAASrG,EAAkB1C,EAAKX,MACtC,OAAI0J,EACO,kBAACA,EAAD,eAAQzH,WAAYI,EAAK1B,KAAMA,GAAUqZ,GAAa/W,GAG1D8W,KAuBLG,GAAqB,SAACnY,EAAyByG,EAAoBuR,GAA6B,IAC1FC,EAAqBjY,EAArBiY,WAAYrZ,EAASoB,EAATpB,KACD6H,EAAOpI,MAAM6H,SAASvF,MAAMyX,QAAQxZ,GACvD,OACI,kBAAC,GAAD,CAAcA,KAAMA,EAAM4W,SAAUyC,EAAU,KArBlC,SAAC5M,EAAoBrL,EAAyByG,EAAoBuR,GAA6B,IACvG9W,EAAmBlB,EAAnBkB,SAAUtC,EAASoB,EAATpB,KAD4F,EAE/EoB,EAAMiY,WAA7B3X,EAFsG,EAEtGA,IAAQ2X,EAF8F,uBAIxGjR,EAASpI,EAAKX,OAASpB,EAAOS,MAC9B+a,GACApX,EAAiBrC,EAAKX,MAC5B,OAAI+I,EACO,kBAACA,EAAD,eAAO9G,WAAYI,EAAK1B,KAAMA,GAAUqZ,GAAa/W,GAGzD8W,IAWEM,CAAYjN,EAAYrL,EAAOyG,EAAQuR,KAQ9CO,GAAe,SAACC,EAAyBC,GAA1B,OACjB,SAACC,EAAgBjS,EAAoBuR,GAMjC,OALAQ,EAAU,CAAE/R,WACPgS,EAAUpI,UAEXoI,EAAUpI,QAAU5J,GAEjBuR,MCrFTnJ,GAAqB,CACvBvG,YACAkQ,UvBmBqB,SAAC,GAAD,IAAWG,EAAX,EAAGlS,OAAH,OAA+C,WACpEA,GAASkS,IuBnBTtP,kBACA4C,gBASE2M,GAAqBvJ,aANH,SAAC3H,GAAD,MAAiB,CACrCrJ,MAAOqJ,EAAMrJ,MACb0F,OAAQ2D,EAAM3D,OACd8U,eAAgBnR,EAAMyB,SAASC,UAGiByF,GAAzBQ,ED2ET,SAACrP,GAA0B,IAErC+D,EAQA/D,EARA+D,OACA1F,EAOA2B,EAPA3B,MACAiK,EAMAtI,EANAsI,SACAkQ,EAKAxY,EALAwY,UACAnP,EAIArJ,EAJAqJ,eACA4C,EAGAjM,EAHAiM,YACA4M,EAEA7Y,EAFA6Y,eACGzY,EATiC,YAUpCJ,EAVoC,2FAYlC8Y,EAAUC,mBAAQ,kBAEpBC,gBElG6B/M,EFoGRA,EEpGkCgN,aAAa,CACxEC,WAAYrM,GACZZ,YAAY,WAAD,8BAAE,WAAOxF,EAAgBwG,GAAvB,kBAAAwG,EAAA,6DACHpI,EAAa5E,EAAOpI,MAAM6H,SAASvF,MAAMyX,QAAQ3R,EAAOpI,MAAM8a,UAD3D,SAEanM,GAAcC,GAF3B,OAEHoH,EAFG,OAGTpI,EAAYZ,EAAYgJ,GAHf,2CAAF,qDAAC,OF8FY,mBDxFrB,SAA8CtQ,GAIjD,IAHA,IAAMqV,EAA+B,GAE/BC,EAA8Cxb,OAAOoH,QAAQlB,EAAOO,QAAU,IAHT,wBAI/DQ,GAJ+D,uBAIpDiC,EAJoD,KAKvE,IAAKA,EAAMrH,OAAQ,iBAEnB0Z,EAAQ3W,KAAK,IAAI6W,KAAkB,CAC/BC,YAAaxS,EAAMrH,OACnByU,MAAO,CACHqF,cAAe,SAEnBC,KAL+B,SAK1BhT,EAAgB7H,GACjB,IAAM8a,EAAgB5B,GAAShT,GAC/B,QAAK4U,EAAc9a,KAIO6H,EAAOpI,MAAM6H,SAASvF,MAAMqI,KAAK0Q,QAdvE,MAAiCL,EAAjC,eAAgD,KAAD,MAoB/C,OAAOD,ECsEAO,CAAqC5V,IANpB,CAQpB6V,aAAU,CAAEC,OAAO,MExGS,IAAC5N,IFyG9B,CAAClI,EAAQkI,IAGN6N,EjBhHH,WACH,IAAMC,EAAgB,iBAAO,CACzBC,WAAYpY,OAAOoY,WACnBC,YAAarY,OAAOqY,cAHI,EAKQ7J,mBAAS2J,GALjB,mBAKrBD,EALqB,KAKTI,EALS,KAMtBC,EAAe,kBAAMD,EAAcH,MAOzC,OANAvJ,qBAAU,WAEN,OADA5O,OAAOwY,iBAAiB,SAAUD,GAC3B,WACHvY,OAAOyY,oBAAoB,SAAUF,OAGtCL,EiBmGYQ,GACbC,EjBjGH,WACH,IAAMC,EAAkB,iBAAO,CAC3BC,QAAS7Y,OAAO6Y,QAChBC,QAAS9Y,OAAO8Y,UAHU,EAKUtK,mBAASoK,GALnB,mBAKvBD,EALuB,KAKTI,EALS,KAMxBC,EAAe,kBAAMD,EAAgBH,MAO3C,OANAhK,qBAAU,WAEN,OADA5O,OAAOwY,iBAAiB,SAAUQ,GAC3B,WACHhZ,OAAOyY,oBAAoB,SAAUO,OAGtCL,EiBoFcM,GACrBrK,qBAAU,WACNnH,MACD,CAACA,EAAgByQ,EAAYS,IAEhC,IAAM9B,EAAY7I,iBAAO,MAEzB,OACI,oCACI,kBAAC,KAAD,eACItP,IAAKmY,EACLxY,UAAU,SACVqY,YAAaH,GACbI,aAAcA,GAAaC,EAAWC,GACtCP,aAAcA,GACdH,WAAYA,GACZhU,OAAQA,EACR1F,MAAOA,EACPiK,SAAUA,EACVwQ,QAASA,GACL1Y,IAGPyY,GAAkB,kBAAC,GAAD,UGzDzBiC,IAFiBlZ,OAAM,sCACcmZ,KACTC,YAAgBC,MAC5CC,GAAQC,axBrDS,WAAyC,IAAxCzT,EAAuC,uDAA/B6E,GAAe6O,EAAgB,uCAC3D,OAAQA,EAAOnd,MACX,KAAK2J,GAKD,OAJAyT,YAAW,WACP1O,aAAa2O,QAvBH,QAuB8B/V,KAAKC,UAAU4V,EAAO/c,UAC/D,GAEIqJ,EAAMnJ,IAAI,QAAS6c,EAAO/c,OAC5BE,IAAI,mBAAmB,GAGhC,KAAKsJ,GACD,OAAOH,EACFnJ,IAAI,mBAAoB6c,EAAO1S,kBAC/BnK,IAAI,mBAAmB,GACvBA,IAAI,2BAA2B,GAGxC,KAAKuJ,GACD,OAAOJ,EAAMnJ,IACT,WACAmJ,EAAMyB,SACD5K,IAAI,SAAU6c,EAAOhS,QACrB7K,IAAI,gBAAiB6c,EAAO/Q,eAC5B9L,IAAI,gBAAiB6c,EAAOzR,gBAIzC,KAAK5B,GACD,OAAOL,EACFnJ,IAAI,kBAAmB6c,EAAOhS,QAC9B7K,IAAI,2BAA2B,GAGxC,KAAKyJ,GACD,OAAON,EACFnJ,IAAI,0BAA2B6c,EAAOhS,QAG/C,QACI,OAAO1B,KwBefoT,IAwBWS,OArBf,WACI,OACI,kBAAC,IAAD,CAAUL,MAAOA,IACb,6BAASjb,UAAU,QACf,gCACI,kBAAC,YAAD,CACIub,KAAK,eACLC,OAAQ,CAAC,mBACTC,OAAO,0BACPvT,KAAMqM,OAAKtD,KAGnB,kBAAC,GAAD,CAAWyK,YAAY,IACvB,gCACI,kBAAC,SAAD,CAAQnE,UAAQ,GAAhB,eClGpBoE,IAASC,OAAO,kBAAC,GAAD,MAAQ3V,SAAS4V,eAAe,W","file":"static/js/main.12356a19.chunk.js","sourcesContent":["/**\n * Enum of alignment values.\n */\nexport enum Align {\n    left = 'left',\n    center = 'center',\n    right = 'right',\n}\n\n/**\n * Block node alignment predicate.\n */\nexport const align = (v: any) => !v || v in Align;\nalign.values = Object.values(Align);\nalign.default = Align.left;\n\n/**\n * Enum of image placement values.\n */\nexport enum ImagePlacement {\n    inline = 'inline',\n    break = 'break',\n}\n\n/**\n * Image placement predicate.\n */\nexport const placement = (v: any) => !v || v in ImagePlacement;\nplacement.values = Object.values(ImagePlacement);\nplacement.default = ImagePlacement.break;\n\n/**\n * Link href.\n */\nexport const href = (v: any) => typeof v === 'string';\n\n/**\n * Image src.\n */\nexport const src = (v: any) => typeof v === 'string';","/**\n * Enum of block node types.\n */\nexport const BLOCKS = {\n    headline: 'headline',\n    title: 'title',\n    subtitle: 'subtitle',\n    body: 'body',\n    unorderedlist: 'unordered-list',\n    orderedlist: 'ordered-list',\n    listitem: 'list-item',\n    preformatted: 'preformatted',\n    image: 'image',\n};\n\n/**\n * Enum of inline node types.\n */\nexport const INLINES = {\n    link: 'link'\n};\n\n/**\n * Enum of mark node types.\n */\nexport const MARKS = {\n    bold: 'bold',\n    italic: 'italic',\n    underlined: 'underlined',\n};\n\nexport const ALL_MARKS = Object.values(MARKS).map(mark => ({ type: mark }));\n","/**\n * Get value from map with key or generate it from constructor function.\n */\n\nimport { get } from 'lodash';\nimport { Block, Inline, Rules } from 'slate';\n\nexport function getOrInit<T>(map: Record<string, T>, key: string, Constructor: (new () => T)) {\n    let value = map[key];\n    if (!value) {\n        value = map[key] = new Constructor();\n    }\n    return value;\n}\n\n/**\n * Add all elements of an Array into a Set.\n * @param  set   Set to add into\n * @param  array Elements to add\n */\nexport function addAll<T>(set: Set<T>, array: Array<T>) {\n    array.forEach(set.add, set);\n}\n\n/**\n * Delete all elements of an Array into a Set.\n * @param set   Set to delete from\n * @param array Elements to delete\n */\nexport function deleteAll<T>(set: Set<T>, array: Array<T>) {\n    array.forEach(set.delete, set);\n}\n\n/**\n * Get data from node or try to get the default value from schema (if provided).\n */\nexport function getNodeData(node: Block | Inline, dataKey: string, blockSchema?: Rules) {\n    const defaultValue = get(blockSchema, ['data', dataKey, 'default']);\n    if (!node.data) {\n        return defaultValue;\n    }\n    return node.data.get(dataKey, defaultValue);\n}","import classNames from 'classnames';\nimport React, { RefObject } from 'react';\n\nimport './index.scss';\nimport { getNodeData } from '../../../editor/utils';\nimport { ALL_MARKS } from '../../constants';\nimport { align } from '../../schema';\nimport { IBaseBlockProps } from '../index';\n\nexport const BODY_SCHEMA = {\n    data: { align },\n    // TODO: move this out?\n    helper: 'What would you like to share?',\n    marks: ALL_MARKS,\n};\n\ninterface IProps extends IBaseBlockProps {\n    elementRef: RefObject<HTMLParagraphElement>;\n}\n\nexport const Body: React.FC<IProps> = (props) => {\n    const {\n        children,\n        className,\n        elementRef,\n        node,\n        ...forwardedProps\n    } = props;\n\n    const align = getNodeData(node, 'align', BODY_SCHEMA);\n    return (\n        <p\n            className={classNames(\n                className,\n                'wrex-content-body',\n                `wrex-content-body--align-${align}`,\n            )}\n            ref={elementRef}\n            {...forwardedProps}\n        >\n            {children}\n        </p>\n    )\n};\n","import classNames from 'classnames';\nimport React, { RefObject } from 'react';\n\nimport './index.scss';\nimport { getNodeData } from '../../../editor/utils';\nimport { align, placement, src } from '../../schema';\nimport { IBaseBlockProps } from '../index';\n\nexport const IMAGE_SCHEMA = {\n    isVoid: true,\n    data: { src, align, placement }\n};\n\ninterface IProps extends IBaseBlockProps {\n    elementRef: RefObject<HTMLElement>;\n    imageRef: RefObject<HTMLImageElement>;\n}\n\nexport const Image: React.FC<IProps> = (props) => {\n    const {\n        className,\n        elementRef,\n        imageRef,\n        node,\n        ...forwardedProps\n    } = props;\n\n    const align = getNodeData(node, 'align', IMAGE_SCHEMA);\n    const placement = getNodeData(node, 'placement', IMAGE_SCHEMA);\n    const caption = getNodeData(node, 'caption');\n    const src = getNodeData(node, 'src');\n    return (\n        <figure\n            ref={elementRef}\n            className={classNames(\n                className,\n                'wrex-content-figure',\n                `wrex-content-figure--placement-${placement}`,\n                `wrex-content-figure--placement-${placement}-${align}`,\n            )}\n            contentEditable={false}\n            {...forwardedProps}\n        >\n            <img\n                ref={imageRef}\n                alt={caption}\n                className='wrex-content-figure__image'\n                src={src}\n            />\n            {caption && <figcaption className='wrex-content-figure__caption'>{caption}</figcaption>}\n        </figure>\n    )\n};","import classNames from 'classnames';\nimport React, { RefObject } from 'react';\n\nimport './index.scss';\nimport { ALL_MARKS, BLOCKS } from '../../constants';\nimport { IBaseBlockProps } from '../index';\n\nexport const LIST_ITEM_SCHEMA = {\n    marks: ALL_MARKS,\n    nodes: [\n        { match: { object: 'text' } },\n        { match: { type: BLOCKS.orderedlist } },\n        { match: { type: BLOCKS.unorderedlist } },\n    ]\n};\n\ninterface IProps extends IBaseBlockProps {\n    elementRef: RefObject<HTMLLIElement>;\n}\n\nexport const ListItem: React.FC<IProps> = (props) => {\n    const {\n        children,\n        className,\n        elementRef,\n        node,\n        ...forwardedProps\n    } = props;\n\n    return (\n        <li\n            className={classNames(className, 'wrex-content-list-item')}\n            ref={elementRef}\n            {...forwardedProps}\n        >\n            {children}\n        </li>\n    )\n};","import classNames from 'classnames';\nimport React, { RefObject } from 'react';\n\nimport './index.scss';\nimport { BLOCKS } from '../../constants';\nimport { IBaseBlockProps } from '../index';\n\nexport const ORDERED_LIST_SCHEMA = {\n    nodes: [{ match: { type: BLOCKS.listitem, min: 1 } }]\n};\n\ninterface IProps extends IBaseBlockProps {\n    elementRef: RefObject<HTMLOListElement>;\n}\n\nexport const OrderedList: React.FC<IProps> = (props) => {\n    const {\n        children,\n        className,\n        elementRef,\n        node,\n        ...forwardedProps\n    } = props;\n\n    return (\n        <ol\n            className={classNames(className, 'wrex-content-unordered-list')}\n            ref={elementRef}\n            {...forwardedProps}\n        >\n            {children}\n        </ol>\n    )\n};","import classNames from 'classnames';\nimport React, { RefObject } from 'react';\n\nimport './index.scss';\nimport { BLOCKS } from '../../constants';\nimport { IBaseBlockProps } from '../index';\n\nexport const UNORDERED_LIST = {\n    nodes: [{ match: { type: BLOCKS.listitem, min: 1 } }]\n};\n\ninterface IProps extends IBaseBlockProps {\n    elementRef: RefObject<HTMLUListElement>;\n}\n\nexport const UnorderedList: React.FC<IProps> = (props) => {\n    const {\n        children,\n        className,\n        elementRef,\n        node,\n        ...forwardedProps\n    } = props;\n\n    return (\n        <ul\n            className={classNames(className, 'wrex-content-unordered-list')}\n            ref={elementRef}\n            {...forwardedProps}\n        >\n            {children}\n        </ul>\n    )\n};","import { BLOCKS } from '../constants';\nimport { Body } from './Body';\nimport { Headline } from './Headline';\nimport { Image } from './Image';\nimport { ListItem } from './ListItem';\nimport { OrderedList } from './OrderedList';\nimport { Preformatted } from './Preformatted';\nimport { Subtitle } from './Subtitle';\nimport { Title } from './Title';\nimport { UnorderedList } from './UnorderedList';\nimport { Block } from 'slate';\nimport React, { ReactNode, RefObject } from 'react';\nimport { IGenericProps } from '@lumx/react/lumx.react';\n\nexport interface IBaseBlockProps extends IGenericProps {\n    children?: ReactNode;\n    className?: string;\n    elementRef?: RefObject<HTMLElement>;\n    node: Block;\n}\n\n/**\n * Index of block components by type.\n */\nexport const BLOCK_COMPONENTS = {\n    [BLOCKS.headline]: Headline,\n    [BLOCKS.title]: Title,\n    [BLOCKS.subtitle]: Subtitle,\n    [BLOCKS.body]: Body,\n    [BLOCKS.preformatted]: Preformatted,\n    [BLOCKS.unorderedlist]: UnorderedList,\n    [BLOCKS.orderedlist]: OrderedList,\n    [BLOCKS.listitem]: ListItem,\n    [BLOCKS.image]: Image,\n} as Record<string, React.FC<IBaseBlockProps>>;","import classNames from 'classnames';\nimport React, { ReactNode, RefObject } from 'react';\n\nimport './index.scss';\nimport { IBaseBlockProps } from '../index';\n\nexport const HEADLINE_SCHEMA = {\n    // TODO: move this out?\n    helper: 'Title',\n    marks: []\n};\n\ninterface IProps extends IBaseBlockProps {\n    children: ReactNode;\n    className: string;\n    elementRef: RefObject<HTMLHeadingElement>;\n}\n\nexport const Headline: React.FC<IProps> = (props) => {\n    const {\n        children,\n        className,\n        elementRef,\n        node,\n        ...forwardedProps\n    } = props;\n\n    return (\n        <h1\n            className={classNames(className, 'wrex-content-headline')}\n            ref={elementRef}\n            {...forwardedProps}\n        >\n            {children}\n        </h1>\n    )\n};","import classNames from 'classnames';\nimport React, { RefObject } from 'react';\n\nimport './index.scss';\nimport { IBaseBlockProps } from '../index';\n\nexport const TITLE_SCHEMA = {\n    marks: [],\n};\n\ninterface IProps extends IBaseBlockProps {\n    elementRef: RefObject<HTMLHeadingElement>;\n}\n\nexport const Title: React.FC<IProps> = (props) => {\n    const {\n        children,\n        className,\n        elementRef,\n        node,\n        ...forwardedProps\n    } = props;\n\n    return (\n        <h2\n            className={classNames(className, 'wrex-content-title')}\n            ref={elementRef}\n            {...forwardedProps}\n        >\n            {children}\n        </h2>\n    )\n};","import classNames from 'classnames';\nimport React, { RefObject } from 'react';\n\nimport './index.scss';\nimport { IBaseBlockProps } from '../index';\n\nexport const SUBTITLE_SCHEMA = {\n    marks: [],\n};\n\ninterface IProps extends IBaseBlockProps {\n    elementRef: RefObject<HTMLHeadingElement>;\n}\n\nexport const Subtitle: React.FC<IProps> = (props) => {\n    const {\n        children,\n        className,\n        elementRef,\n        node,\n        ...forwardedProps\n    } = props;\n\n    return (\n        <h3\n            className={classNames(className, 'wrex-content-subtitle')}\n            ref={elementRef}\n            {...forwardedProps}\n        >\n            {children}\n        </h3>\n    )\n};","import classNames from 'classnames';\nimport React, { RefObject } from 'react';\n\nimport './index.scss';\nimport { IBaseBlockProps } from '../index';\n\nexport const PREFORMATTED_SCHEMA = {\n    marks: [],\n    nodes: [{ match: { object: 'text' } }]\n};\n\ninterface IProps extends IBaseBlockProps {\n    elementRef: RefObject<HTMLPreElement>;\n}\n\nexport const Preformatted: React.FC<IProps> = (props) => {\n    const {\n        children,\n        className,\n        elementRef,\n        node,\n        ...forwardedProps\n    } = props;\n\n    return (\n        <pre\n            className={classNames(className, 'wrex-content-preformatted')}\n            ref={elementRef}\n            {...forwardedProps}\n        >\n            {children}\n        </pre>\n    )\n};","import { MARKS } from '../constants';\nimport { Bold } from './Bold';\nimport { Italic } from './Italic';\nimport { Underlined } from './Underlined';\n\n/**\n * Index of mark components by type.\n */\nexport const MARK_COMPONENTS = {\n    [MARKS.bold]: Bold,\n    [MARKS.italic]: Italic,\n    [MARKS.underlined]: Underlined,\n};","import React, { ReactNode, RefObject } from 'react';\nimport { IGenericProps } from '@lumx/react/lumx.react';\n\ninterface IProps extends IGenericProps {\n    children: ReactNode;\n    elementRef: RefObject<HTMLElement>;\n}\n\nexport const Bold = ({ children, elementRef, ...props }: IProps) => (\n    <strong ref={elementRef} {...props}>{children}</strong>\n);","import React, { ReactNode, RefObject } from 'react';\nimport { IGenericProps } from '@lumx/react/lumx.react';\n\ninterface IProps extends IGenericProps {\n    children: ReactNode;\n    elementRef: RefObject<HTMLElement>;\n}\n\nexport const Italic = ({ children, elementRef, ...props }: IProps) => (\n    <em ref={elementRef} {...props}>{children}</em>\n);","import React, { ReactNode, RefObject } from 'react';\nimport { IGenericProps } from '@lumx/react/lumx.react';\n\ninterface IProps extends IGenericProps {\n    children: ReactNode;\n    elementRef: RefObject<HTMLElement>;\n}\n\nexport const Underlined = ({ children, elementRef, ...props }: IProps) => (\n    <u ref={elementRef} {...props}>{children}</u>\n);","import classNames from 'classnames';\nimport React, { ReactNode, RefObject } from 'react';\n\nimport './index.scss';\nimport { href } from '../../schema';\nimport { Inline } from 'slate';\nimport { IBaseInlineProps } from '../index';\n\nexport const LINK_SCHEMA = {\n    data: { href },\n    marks: [],\n    nodes: [{\n        match: { object: 'text' }\n    }]\n};\n\ninterface IProps extends IBaseInlineProps {\n    children: ReactNode;\n    elementRef: RefObject<HTMLAnchorElement>;\n    node: Inline;\n}\n\nexport const Link: React.FC<IProps> = (props) => {\n    const {\n        children,\n        className,\n        elementRef,\n        node,\n        ...forwardedProps\n    } = props;\n\n    const href = node.data && node.data.get('href');\n    const onClick = (evt: React.MouseEvent) => {\n        if (evt.ctrlKey) {\n            evt.preventDefault();\n            evt.stopPropagation();\n            window.open(href, '_blank');\n        }\n    };\n    return (\n        <a\n            ref={elementRef}\n            className={classNames(className, 'wrex-content-link')}\n            href={href}\n            onClick={onClick}\n            {...forwardedProps}\n        >\n            {children}\n        </a>\n    )\n};","import { INLINES } from '../constants';\nimport { Link } from './Link';\nimport { IGenericProps } from '@lumx/react/lumx.react';\nimport { ReactNode, RefObject } from 'react';\nimport { Inline } from 'slate';\n\n\nexport interface IBaseInlineProps extends IGenericProps {\n    children?: ReactNode;\n    className?: string;\n    elementRef?: RefObject<HTMLElement>;\n    node: Inline;\n}\n\n/**\n * Index of inline components by type.\n */\nexport const INLINE_COMPONENTS = {\n    [INLINES.link]: Link,\n};","import { BLOCKS } from '../content/';\n\nexport const EMPTY_DOCUMENT = {\n    'object': 'value',\n    'document': {\n        'object': 'document',\n        'nodes': [\n            {\n                'object': 'block',\n                'type': BLOCKS.headline,\n                'nodes': [\n                    {\n                        'object': 'text',\n                        'text': ''\n                    }\n                ]\n            },\n            {\n                'object': 'block',\n                'type': BLOCKS.body,\n                'nodes': [\n                    {\n                        'object': 'text',\n                        'text': ''\n                    }\n                ]\n            },\n        ]\n    }\n};","import { castArray, flatMap, flatten, get, mapValues, unary } from 'lodash';\nimport { addAll, deleteAll, getOrInit } from '../utils';\nimport memoizeOne from 'memoize-one';\nimport { Document, ObjectAndType, SchemaProperties, Text } from 'slate';\n\nfunction getNodeMatchTypes(node: ObjectMatch) {\n    return flatMap(castArray(node.match), 'type');\n}\n\n/**\n * Get list of the next nodes after index.\n * Will return multiple nodes iff the next node(s) are optional (min < 1).\n */\nfunction getNextBlocks(nodes: ObjectMatch[], index: number) {\n    let i = index + 1;\n    const flatNode = flatten(nodes);\n    const nextNodes: string[] = [];\n    let nextNode = flatNode[i];\n    while (nextNode) {\n        nextNodes.push(...getNodeMatchTypes(nextNode));\n        if (!Array.isArray(nextNode) && nextNode.min !== 0) {\n            break;\n        }\n        i++;\n        nextNode = flatNode[i];\n    }\n    return nextNodes;\n}\n\n/**\n * Suffix node type to mark the occurrence number in the state machine.\n */\nfunction getNodeId(nodeType: string, occurrence = 0) {\n    return `${nodeType}${occurrence}`;\n}\n\n/**\n * Split node id into an object with node type and node occurrence.\n * @param  {string}                             nodeId\n * @return {{occurrence: number, type: string}} node object\n */\nfunction nodeIdToNodeObject(nodeId: string): DetailedNode {\n    const matches = nodeId.match(/(\\D+)(\\d+)/);\n    const [, type, occurrence] = matches!;\n    return { occurrence: parseInt(occurrence), type };\n}\n\ntype DirectedGraph = Record<string, Set<string>>;\n\ntype DetailedNode = {\n    occurrence: number;\n    type: string;\n}\ntype DetailedDirectedGraph = Record<string, DetailedNode[]>;\n\n/**\n * Converts the algo-friendly directed graph format (object of Set of string) to a consumer-friendly\n * format (object of array of object (node type & occurrence number).\n *\n * @param  directedGraph Algo-friendly directed graph\n * @return Consumer-friendly directed graph\n */\nfunction toConsumerFriendlyGraph(directedGraph: DirectedGraph): DetailedDirectedGraph {\n    return mapValues(\n        directedGraph,\n        (nodeOccurrenceSet) => Array.from(nodeOccurrenceSet).map(nodeIdToNodeObject)\n    )\n}\n\nexport type ObjectMatch = {\n    min?: number;\n    max?: number;\n    match?: ObjectAndType | ObjectAndType[];\n};\n\nexport const GRAPH_START_NODE = '__START';\n\n/**\n * Transform a SlateJS schema to a directed graph represented as a JS object with blocks as keys and set of possible\n * next sibling blocks.\n *\n * The block types are suffixed with a number to handle succession of repeated same-type blocks constrained by\n * min or max.\n */\nfunction toDirectedGraph(schema: SchemaProperties): DirectedGraph {\n    const nodes: ObjectMatch[] = get(schema, 'document.nodes');\n    const blockTypes = Object.keys(schema.blocks || {});\n    const directedGraph: DirectedGraph = { [GRAPH_START_NODE]: new Set() };\n\n    // Has no document schema or block schema\n    const noDocSchema = !Array.isArray(nodes);\n    const noDocNoBlockSchema = noDocSchema && blockTypes.length === 0;\n    // Has empty document schema\n    const emptyDocSchema = Array.isArray(nodes) && nodes.length === 0;\n    if (noDocNoBlockSchema || emptyDocSchema) {\n        return directedGraph;\n    }\n\n    if (noDocSchema) {\n        const suffixedBlocks = blockTypes.map(b => `${b}0`);\n        directedGraph[GRAPH_START_NODE] = new Set(suffixedBlocks);\n        for (const blockType of suffixedBlocks) {\n            directedGraph[blockType] = new Set(suffixedBlocks);\n        }\n        return directedGraph;\n    }\n\n    // Init start\n    const firstNodes = getNextBlocks(nodes, -1).map(unary(getNodeId));\n    addAll(getOrInit(directedGraph, GRAPH_START_NODE, Set), firstNodes);\n\n    for (const [sIndex, sNode] of Object.entries(nodes)) {\n        for (const node of castArray(sNode)) {\n            const index = parseInt(sIndex);\n            const max = node.max === undefined ? Infinity : node.max;\n            const min = node.min === undefined ? 1 : node.min;\n            if (max < min) {\n                throw new Error(`Max < min in '${JSON.stringify(node)}'`);\n            }\n\n            const matchTypes = getNodeMatchTypes(node);\n\n            let occurrence = 0;\n            const getCurrentOccurrenceNodeId = (matchType: string) => getNodeId(matchType, occurrence);\n            const getNextOccurrenceNodeId = (matchType: string) => getNodeId(matchType, occurrence + 1);\n            const nextNodes = getNextBlocks(nodes, index).map(unary(getNodeId));\n\n            if (min < 1) {\n                for (const matchType of matchTypes) {\n                    const nodeId = getNodeId(matchType);\n                    const nextNodeSet = getOrInit(directedGraph, nodeId, Set);\n                    addAll(nextNodeSet, nextNodes);\n                    if (max === Infinity) {\n                        const nodeIds = matchTypes.map(getNodeId);\n                        addAll(nextNodeSet, nodeIds);\n                    }\n                }\n            } else {\n                while (occurrence < min) {\n                    for (const matchType of matchTypes) {\n                        let nodeId = getNodeId(matchType, occurrence);\n                        const nextNodeSet = getOrInit(directedGraph, nodeId, Set);\n                        if (occurrence === min - 1) {\n                            const nodeIds = matchTypes.map(getCurrentOccurrenceNodeId);\n                            addAll(nextNodeSet, nodeIds);\n                            addAll(nextNodeSet, nextNodes);\n                        } else {\n                            const nodeIds = matchTypes.map(getNextOccurrenceNodeId);\n                            addAll(nextNodeSet, nodeIds);\n\n                        }\n                    }\n                    occurrence++;\n                }\n            }\n\n            if (max !== Infinity) {\n                occurrence = min < 1 ? 0 : min - 1;\n                while (occurrence < max) {\n                    for (const matchType of matchTypes) {\n                        let nodeId = getNodeId(matchType, occurrence);\n                        const nextNodeSet = getOrInit(directedGraph, nodeId, Set);\n                        addAll(nextNodeSet, nextNodes);\n                        if (occurrence !== max - 1) {\n                            const nodeIds = matchTypes.map(getNextOccurrenceNodeId);\n                            addAll(nextNodeSet, nodeIds);\n                        } else {\n                            const nodeIds = matchTypes.map(getCurrentOccurrenceNodeId);\n                            deleteAll(nextNodeSet, nodeIds);\n                        }\n                    }\n                    occurrence++;\n                }\n            }\n        }\n    }\n    return directedGraph;\n}\n\n/**\n * Get next node in graph for node type & occurrence.\n *\n * @param  graph\n * @param  nodeType\n * @param  nodeOccurrence\n */\nexport function getNextInGraph(graph: DetailedDirectedGraph, nodeType: string, nodeOccurrence: number) {\n    const nodeId = getNodeId(nodeType, nodeOccurrence);\n    let possibleNodes = graph[nodeId];\n    if (!possibleNodes && nodeOccurrence > 0) {\n        const occurrenceNumbers = Object.keys(graph)\n            .filter((nodeId) => nodeId !== GRAPH_START_NODE)\n            .map(nodeIdToNodeObject)\n            .filter(({ type }) => nodeType === type)\n            .map(({ occurrence }) => occurrence);\n        const maxOccurrenceNumber = Math.max(...occurrenceNumbers);\n        const nodeId = getNodeId(nodeType, maxOccurrenceNumber);\n        return graph[nodeId];\n    }\n    return possibleNodes;\n}\n\n/**\n * Memoized version of {@see toDirectedGraph} combined with {@see toConsumerFriendlyGraph}.\n * Keeps only the last value. The schema should not change in normal use cases and so\n * should the directed graph.\n */\nconst memoizedSchemaDirectedGraph = memoizeOne((schema) =>\n    toConsumerFriendlyGraph(toDirectedGraph(schema))\n);\n\n/**\n * Get possible blocks in node at location in the document.\n *\n * @param  {Object}         schema   Document schema.\n * @param  {Object}         document Document value.\n * @param  {number}         index    Index in document.\n * @return {Array.<string>} List of possible block type at position in document.\n */\nfunction getPossibleBlocks(schema: SchemaProperties, document: Document, index: number) {\n    const graph = memoizedSchemaDirectedGraph(schema);\n    let possibleNodes = graph[GRAPH_START_NODE] || [];\n\n    let currentIndex = 0;\n    let documentNode = document.nodes.get(currentIndex);\n    if (documentNode instanceof Text) {\n        return [];\n    }\n\n    let currentNode = { occurrence: 0, type: documentNode.type };\n\n    while (possibleNodes.length && documentNode && currentIndex < index) {\n        possibleNodes = getNextInGraph(graph, currentNode.type, currentNode.occurrence);\n\n        currentIndex++;\n        currentNode.occurrence++;\n        documentNode = document.nodes.get(currentIndex);\n        if (!(documentNode instanceof Text) && currentNode.type !== documentNode.type) {\n            currentNode = { occurrence: 0, type: documentNode.type };\n        }\n    }\n\n    return possibleNodes.map(({ type }) => type);\n}\n\n/**\n * Memoized version of {@see getPossibleBlocks}\n * Keeps only the last value.\n */\nexport const memoizedGetPossibleBlocks = memoizeOne(getPossibleBlocks);\n\nexport { toDirectedGraph, getNextBlocks, getPossibleBlocks };","import { Block, Node, SchemaProperties, Text } from 'slate';\nimport { Editor } from 'slate-react';\nimport { BLOCKS, INLINES } from '../content/';\nimport { BODY_SCHEMA } from '../content/block/Body';\nimport { HEADLINE_SCHEMA } from '../content/block/Headline';\nimport { IMAGE_SCHEMA } from '../content/block/Image';\nimport { LIST_ITEM_SCHEMA } from '../content/block/ListItem';\nimport { ORDERED_LIST_SCHEMA } from '../content/block/OrderedList';\nimport { PREFORMATTED_SCHEMA } from '../content/block/Preformatted';\nimport { SUBTITLE_SCHEMA } from '../content/block/Subtitle';\nimport { TITLE_SCHEMA } from '../content/block/Title';\nimport { UNORDERED_LIST } from '../content/block/UnorderedList';\nimport { LINK_SCHEMA } from '../content/inline/Link';\nimport { memoizedGetPossibleBlocks } from './schema-utils';\n\nexport interface INormalizeArgs {\n    code: string;\n    node: Node;\n    child: Node;\n    index: number;\n}\n\nexport interface ISchema extends SchemaProperties {\n    normalize(editor: Editor, args: INormalizeArgs): void;\n}\n\nexport interface HasHelper {\n    helper?: string;\n}\n\n\nfunction normalize(editor: Editor, args: INormalizeArgs) {\n    const { code, node, child, index } = args;\n    if (node.object !== 'document') {\n        return editor;\n    }\n    const possibleBlocks = memoizedGetPossibleBlocks(editor.props.schema!, node, index);\n    const possibleBlockType = possibleBlocks[0];\n\n    switch (code) {\n        case 'child_max_invalid': {\n            const nextNode = node.nodes.get(index + 1);\n            if (nextNode.text) {\n                const block = Block.create({ type: possibleBlockType, nodes: [Text.create({ text: child.text })] });\n                return editor.insertNodeByKey(node.key, index, block);\n            } else {\n                return editor.moveFocusToStartOfNextText().insertText(child.text);\n            }\n        }\n        case 'child_min_invalid': {\n            const block = Block.create({ type: possibleBlockType });\n            return editor.insertNodeByKey(node.key, index, block);\n        }\n        default:\n            return;\n    }\n}\n\nexport const SCHEMA = {\n    blocks: {\n        [BLOCKS.headline]: HEADLINE_SCHEMA,\n        [BLOCKS.title]: TITLE_SCHEMA,\n        [BLOCKS.subtitle]: SUBTITLE_SCHEMA,\n        [BLOCKS.body]: BODY_SCHEMA,\n        [BLOCKS.unorderedlist]: UNORDERED_LIST,\n        [BLOCKS.orderedlist]: ORDERED_LIST_SCHEMA,\n        [BLOCKS.listitem]: LIST_ITEM_SCHEMA,\n        [BLOCKS.preformatted]: PREFORMATTED_SCHEMA,\n        [BLOCKS.image]: IMAGE_SCHEMA,\n    },\n    document: {\n        nodes: [\n            {\n                match: { type: BLOCKS.headline },\n                min: 1,\n                max: 1,\n            },\n            {\n                match: [\n                    { type: BLOCKS.body },\n                    { type: BLOCKS.title },\n                    { type: BLOCKS.subtitle },\n                    { type: BLOCKS.preformatted },\n                    { type: BLOCKS.unorderedlist },\n                    { type: BLOCKS.orderedlist },\n                    { type: BLOCKS.image },\n                ],\n                min: 1\n            },\n        ],\n        normalize,\n    },\n    inlines: {\n        [INLINES.link]: LINK_SCHEMA,\n    }\n};","import { curry, get, intersection, isEmpty } from 'lodash'\nimport { Inline, Mark, Rules, Value } from 'slate';\nimport { Rect } from './actions';\n\nexport function hasTextSelection(state: any) {\n    const { value } = state;\n    const { fragment, selection } = value;\n\n    return !selection.isBlurred && !selection.isCollapsed && fragment.text;\n}\n\n/**\n * Get mark type from mark object or mark string.\n * @param {string|object} mark\n * @param {string}        mark type.\n */\nfunction getMarkType(mark: any) {\n    if (mark instanceof Mark) {\n        return mark.type;\n    } else if (typeof mark === 'string') {\n        return mark;\n    }\n    return null;\n}\n\n/**\n * List possible text mark for the current text selection using the schema.\n */\nexport function getPossibleMarksAtSelection(state: any) {\n    const { value } = state;\n    const { selection, document } = value as Value;\n\n    const blocksAtSelection = document.getLeafBlocksAtRange(selection);\n\n    const marksForBlocksAtSelection = blocksAtSelection\n        .map(getSchemaForNode(state))\n        .map((schema) => schema && schema.marks)\n        .filter(Boolean)\n        .map((marks) => marks!.map(getMarkType))\n        .toJS();\n    const possibleMarks = intersection(...marksForBlocksAtSelection);\n    if (isEmpty(possibleMarks)) {\n        return;\n    }\n    return possibleMarks;\n}\n\n/**\n * NON PURE function that depends on window text selection.\n */\nexport function getTextSelectionRect() {\n    const selection = window.getSelection();\n    if (selection && selection.rangeCount > 0) {\n        return selection.getRangeAt(0).getBoundingClientRect() as Rect;\n    }\n}\n\n\n/**\n * Get block schema for node.\n */\nexport const getSchemaForNode = curry((state: any, node: any): Rules | undefined => {\n    if (node instanceof Inline) {\n        return get(state, ['schema', 'inlines', node.type]);\n    }\n    if ('type' in node) {\n        return get(state, ['schema', 'blocks', node.type]);\n    }\n});","import { List } from 'immutable';\nimport { debounce, get } from 'lodash';\nimport { Align, ImagePlacement } from '../../content/schema';\nimport { getPossibleMarksAtSelection, getSchemaForNode, getTextSelectionRect, hasTextSelection } from './selectors';\nimport { Block, Data, Editor, Inline, Node, Operation, Rules, Selection, Text, Value } from 'slate'\n\nimport { BLOCKS, INLINES } from '../../content/';\n\nexport const DOMAIN = 'WREX';\nexport const CHANGE_VALUE = `${DOMAIN}/CHANGE_VALUE`;\nexport const UPDATE_ACTIVE_BLOCK = `${DOMAIN}/UPDATE_ACTIVE_BLOCK`;\nexport const UPDATE_TEXT_MENU = `${DOMAIN}/UPDATE_TEXT_MENU`;\nexport const SET_BLOCK_MENU_OPEN = `${DOMAIN}/SET_BLOCK_MENU_OPEN`;\nexport const SET_BLOCK_TYPE_DROPDOWN_OPEN = `${DOMAIN}/SET_BLOCK_TYPE_DROPDOWN_OPEN`;\n\n\n/**\n * The reference to the slate editor controller is kept out of the store since its a mutable value.\n * It is necessary in order to call text transformation commands.\n *\n * TODO: find a better way for this.\n */\nlet editor: Editor | null = null;\n\n//TODO: try to avoid\nexport const setEditor = ({ editor: newEditor }: { editor: Editor }) => () => {\n    editor = newEditor;\n};\n\n// TODO: use redux\nexport const toggleMarkOnSelection = (markType: string) => () => {\n    editor!.toggleMark(markType);\n};\n\n// TODO: use redux\nexport const insertLink = (href: string) => () => {\n    editor!.wrapInline({\n        type: INLINES.link,\n        data: { href },\n    });\n\n    editor!.moveToEnd();\n};\n\n// TODO: use redux\nexport const deleteLink = () => () => {\n    editor!.unwrapInline(INLINES.link);\n};\n\nconst trailingBlock = (state: any, value: Value) => {\n    const nodes = value.document.nodes;\n    const lastNode = nodes.get(nodes.size - 1);\n    const lastNodeSchema = lastNode && getSchemaForNode(state, lastNode) as Rules;\n    if (lastNodeSchema && lastNodeSchema.isVoid) {\n        // Add empty body at the end if not present\n        return value.setIn(\n            ['document', 'nodes'],\n            nodes.push(Block.create({\n                type: BLOCKS.body\n            }))\n        )\n    }\n\n    return value;\n};\n\n\nfunction getActiveBlockIndex(value: Value) {\n    if (!value.startBlock) {\n        return;\n    }\n    const startBlockPath = value.document.getPath(value.startBlock);\n    if (!startBlockPath) {\n        return;\n    }\n    return startBlockPath.get(0);\n}\n\nexport const blurCurrentBlock = () => (dispatch: Function, getState: Function) => {\n    const { value } = getState();\n    dispatch(onChange({\n        value: value.set('selection', Selection.create({})),\n    }));\n};\n\nexport const onChange = ({ value, operations }: { value: Value, operations?: List<Operation> }) => (dispatch: Function, getState: Function) => {\n    // Update data related to editor value.\n    const state = getState();\n    dispatch({\n        type: CHANGE_VALUE,\n        value: trailingBlock(state, value),\n        operations,\n    });\n\n    const activeBlockIndex = getActiveBlockIndex(value);\n    if (activeBlockIndex !== undefined) {\n        dispatch(setActiveBlockIndex(activeBlockIndex));\n    }\n\n    // Update selection.\n    if (operations && operations.some(({ type }) => type === 'set_selection')) {\n        debouncedUpdateTextMenu(dispatch);\n    }\n};\n\n\nconst closeTextMenu = () => (dispatch: Function, getState: Function) => {\n    if (!getState().textMenu.isOpen) {\n        return;\n    }\n    dispatch({\n        type: UPDATE_TEXT_MENU,\n        isOpen: false,\n    });\n};\n\n\nexport const updateTextMenu = () => (dispatch: Function, getState: Function) => {\n    const state = getState();\n\n    let hasSelection = hasTextSelection(state);\n    if (!hasSelection) {\n        dispatch(closeTextMenu());\n        return;\n    }\n\n    const possibleMarks = getPossibleMarksAtSelection(state);\n    if (!possibleMarks) {\n        dispatch(closeTextMenu());\n        return;\n    }\n\n    const selectionRect = getTextSelectionRect();\n    if (rectEqual(selectionRect, state.textMenu.selectionRect)) {\n        return;\n    }\n    dispatch({\n        type: UPDATE_TEXT_MENU,\n        isOpen: true,\n        selectionRect,\n        possibleMarks\n    });\n};\n\n\nconst debouncedUpdateTextMenu = debounce((dispatch) => {\n    return dispatch(updateTextMenu())\n}, 5);\n\n\nexport interface Rect {\n    x: number;\n    y: number;\n    height: number;\n    width: number;\n}\n\nfunction rectEqual(rect1?: Rect, rect2?: Rect) {\n    return rect1 === rect2\n        || (rect1 && rect2\n            && rect1.x === rect2.x\n            && rect1.y === rect2.y\n            && rect1.height === rect2.height\n            && rect1.width === rect2.width);\n}\n\n\nexport const setActiveBlockIndex = (activeBlockIndex: number) => (dispatch: Function, getState: Function) => {\n    if (getState().activeBlockIndex === activeBlockIndex) {\n        return;\n    }\n    dispatch({ type: UPDATE_ACTIVE_BLOCK, activeBlockIndex });\n};\n\n\nexport const setBlockMenuOpen = (isOpen: boolean) => (dispatch: Function, getState: Function) => {\n    if (getState().isBlockMenuOpen === isOpen) {\n        return;\n    }\n    if (isOpen) {\n        dispatch(closeTextMenu());\n    }\n    dispatch({ type: SET_BLOCK_MENU_OPEN, isOpen });\n};\n\n\nexport const setBlockTypeDropdownOpen = (isOpen: boolean) => (dispatch: Function, getState: Function) => {\n    if (getState().isBlockTypeDropdownOpen === isOpen) {\n        return;\n    }\n    dispatch({ type: SET_BLOCK_TYPE_DROPDOWN_OPEN, isOpen });\n};\n\n\nexport const changeBlockAlign = (align: Align, blockIndex?: number) => (dispatch: Function, getState: Function) => {\n    const { value, activeBlockIndex } = getState();\n    if (typeof blockIndex !== 'number') {\n        blockIndex = activeBlockIndex;\n    }\n    if (typeof blockIndex !== 'number') {\n        return;\n    }\n\n    dispatch(onChange({\n        value: value.setIn(['document', 'nodes', blockIndex, 'data', 'align'], align)\n    }));\n};\n\nexport const changeImagePlacement = (placement: ImagePlacement, blockIndex?: number) => (dispatch: Function, getState: Function) => {\n    if (typeof blockIndex !== 'number') {\n        return;\n    }\n    const { value } = getState();\n\n    dispatch(onChange({\n        value: value.setIn(['document', 'nodes', blockIndex, 'data', 'placement'], placement)\n    }));\n\n    if (placement === ImagePlacement.inline && value.getIn(['document', 'nodes', blockIndex, 'data', 'align']) === Align.center) {\n        dispatch(changeBlockAlign(Align.left, blockIndex));\n    }\n};\n\nconst isBlock = (node?: any): node is Block => node instanceof Block;\n\nconst isList = (node?: string): node is string => {\n    return BLOCKS.unorderedlist === node || BLOCKS.orderedlist === node;\n};\n\nfunction changeType(nodes: List<Node>, index: number, type: string): List<Node> {\n    const node = nodes.get(index);\n    if (!isBlock(node)) {\n        return nodes;\n    }\n\n    if (isList(node.type) && !isList(type)) {\n        // Split node\n        const splitNodes = node.nodes.filter(isBlock).map((node) =>\n            node!.set('type', type)\n                .set('data', Data.create({})) as Block\n        );\n        return nodes.splice(index, 1, ...splitNodes.toArray());\n    }\n\n    if (!isList(node.type) && isList(type)) {\n        // Wrap in list item\n        const newBlock = node.set('type', BLOCKS.listitem)\n            .set('data', Data.create({})) as Block;\n        const newNodes = List([newBlock]) as List<Block | Inline | Text>;\n        return nodes.set(\n            index,\n            // @ts-ignore\n            Block.create({\n                type,\n                data: Data.create({}),\n                nodes: newNodes\n            })\n        );\n    }\n\n    // Simple case: replace block type\n    return nodes.set(\n        index,\n        node!.set('type', type)\n            .set('data', Data.create({})) as Block\n    ) as List<Node>;\n}\n\nexport const changeBlockType = (type: string) => (dispatch: Function, getState: Function) => {\n    const { value, activeBlockIndex } = getState();\n    if (typeof activeBlockIndex !== 'number') {\n        return;\n    }\n\n    dispatch(onChange({\n        value: value.setIn(['document', 'nodes'], changeType(value.document.nodes, activeBlockIndex, type)),\n    }));\n};\n\n\nexport const insertImage = (blockIndex?: number, image?: string) => (dispatch: Function, getState: Function) => {\n    const state = getState();\n    const { value } = state;\n    if (typeof blockIndex !== 'number') {\n        return\n    }\n    const imageSchema = getSchemaForNode(state, { type: BLOCKS.image });\n    const imageBlock = Block.create({\n        data: Data.create({\n            align: get(imageSchema, 'data.align.default'),\n            placement: get(imageSchema, 'data.placement.default'),\n            src: image,\n        }),\n        type: BLOCKS.image\n    });\n\n    const nodes = value.document.nodes;\n    const node = nodes.get(blockIndex);\n    const blockSchema = getSchemaForNode(state, node);\n    const newNodes = (!node.text && (blockSchema && !blockSchema.isVoid))\n        ? nodes.set(blockIndex, imageBlock)\n        : nodes.insert(blockIndex + 1, imageBlock);\n\n    dispatch(onChange({\n        value: value.setIn(\n            ['document', 'nodes'],\n            newNodes\n        )\n    }));\n};\n\n","import { Record } from 'immutable';\nimport { Value } from 'slate';\nimport { EMPTY_DOCUMENT } from '../../samples/EMPTY_DOCUMENT';\nimport { SCHEMA } from '../SCHEMA';\nimport {\n    CHANGE_VALUE,\n    SET_BLOCK_MENU_OPEN,\n    SET_BLOCK_TYPE_DROPDOWN_OPEN,\n    UPDATE_ACTIVE_BLOCK,\n    UPDATE_TEXT_MENU\n} from './actions';\n\nconst LOCAL_STORAGE_KEY = 'value';\n\nconst TextMenu = Record({\n    isOpen: false,\n    possibleMarks: undefined,\n    selectionRect: undefined,\n});\n\nconst DEFAULT_STATE = Record({\n    value: Value.fromJSON(\n        JSON.parse(localStorage.getItem(LOCAL_STORAGE_KEY) || JSON.stringify(EMPTY_DOCUMENT))\n    ),\n    schema: SCHEMA,\n    activeBlockIndex: undefined,\n    isBlockMenuOpen: false,\n    isBlockTypeDropdownOpen: false,\n    textMenu: TextMenu(),\n})();\n\nexport const reducer = (state = DEFAULT_STATE, action: any) => {\n    switch (action.type) {\n        case CHANGE_VALUE: {\n            setTimeout(() => {\n                localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(action.value));\n            }, 0);\n\n            return state.set('value', action.value)\n                .set('isBlockMenuOpen', false);\n        }\n\n        case UPDATE_ACTIVE_BLOCK: {\n            return state\n                .set('activeBlockIndex', action.activeBlockIndex)\n                .set('isBlockMenuOpen', false)\n                .set('isBlockTypeDropdownOpen', false);\n        }\n\n        case UPDATE_TEXT_MENU: {\n            return state.set(\n                'textMenu',\n                state.textMenu\n                    .set('isOpen', action.isOpen)\n                    .set('selectionRect', action.selectionRect)\n                    .set('possibleMarks', action.possibleMarks)\n            );\n        }\n\n        case SET_BLOCK_MENU_OPEN: {\n            return state\n                .set('isBlockMenuOpen', action.isOpen)\n                .set('isBlockTypeDropdownOpen', false);\n        }\n\n        case SET_BLOCK_TYPE_DROPDOWN_OPEN: {\n            return state\n                .set('isBlockTypeDropdownOpen', action.isOpen);\n        }\n\n        default:\n            return state;\n    }\n};","export const IMAGE_EXTENSIONS = ['gif', 'jpg', 'jpeg', 'png'];\nexport const IMAGE_TYPES = IMAGE_EXTENSIONS.map((ext) => `image/${ext}`);\n\nexport const filterImages = (files: Blob[]) => files.filter((file) => IMAGE_TYPES.includes(file.type));\n\nexport const readAsDataURL = (file: Blob) => new Promise<string>((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onload = (e) => {\n        e.target && resolve(e.target.result as string);\n    };\n    reader.onerror = reject;\n    reader.readAsDataURL(file);\n});\n","import React, { useRef } from 'react';\n\nimport { isEmpty } from 'lodash';\n\nimport { mdiFormatBold, mdiFormatItalic, mdiFormatUnderline, mdiLink } from '@lumx/icons';\nimport { ColorPalette, Emphasis, IconButton, Placement, Popover } from '@lumx/react';\n\nimport { MARKS } from '../../../content/';\nimport { useComputePositionFromRect } from '../../hooks';\nimport './TextMenu.scss';\nimport { Rect } from '../../ducks/actions';\nimport { Mark } from 'slate';\n\nconst ICONS = {\n    [MARKS.bold]: mdiFormatBold,\n    [MARKS.italic]: mdiFormatItalic,\n    [MARKS.underlined]: mdiFormatUnderline,\n};\n\ntype onToggleMarkType = (markType: string) => void;\n\ninterface IMarkButtonProps {\n    markType: string;\n    isSelected: boolean;\n\n    onToggleMark: onToggleMarkType;\n}\n\nconst MarkButton = ({ markType, isSelected, onToggleMark }: IMarkButtonProps) => (\n    <IconButton\n        color={ColorPalette.light}\n        emphasis={Emphasis.low}\n        icon={ICONS[markType] || mdiFormatBold}\n        isSelected={isSelected}\n        onMouseDown={(event: MouseEvent) => {\n            event.preventDefault();\n            onToggleMark(markType);\n        }}\n    />\n);\ntype insertLinkType = (link: string) => void;\ntype deleteLinkType = () => void;\n\ninterface IProps {\n    targetRect: Rect,\n    activeMarks: Mark[],\n    marks: string[],\n    hasLinks: boolean,\n    insertLink: insertLinkType,\n    onToggleMark: onToggleMarkType;\n    deleteLink: deleteLinkType\n}\n\nconst TextMenu = ({ targetRect, activeMarks, marks, onToggleMark, hasLinks, insertLink, deleteLink }: IProps) => {\n    const popoverRef = useRef(null);\n    const { computedPosition, isVisible } = useComputePositionFromRect(\n        Placement.BOTTOM,\n        targetRect,\n        popoverRef,\n        true,\n        { vertical: 8 }\n    );\n\n    const isSelected = (type: string) => Boolean(activeMarks.find(m => m.type === type));\n\n    return (\n        <Popover\n            isVisible={isVisible}\n            className=\"editor-hovering-menu\"\n            popoverRect={computedPosition}\n            popoverRef={popoverRef}\n        >\n            {marks.map((markType) => (\n                <MarkButton\n                    key={markType}\n                    markType={markType}\n                    isSelected={isSelected(markType)}\n                    onToggleMark={onToggleMark}\n                />\n            ))}\n            {!isEmpty(marks) && <div className=\"editor-menu__vertical-divider\"/>}\n            <IconButton\n                color={ColorPalette.light}\n                emphasis={Emphasis.low}\n                icon={mdiLink}\n                isSelected={hasLinks}\n                onMouseDown={(event: MouseEvent) => {\n                    event.preventDefault();\n                    if (hasLinks) {\n                        deleteLink();\n                    } else {\n                        //TODO: use a dialog\n                        const href = prompt('Enter the URL of the link:');\n                        if (href) {\n                            insertLink(href);\n                        }\n                    }\n                }}\n            />\n        </Popover>\n    );\n};\n\nexport { TextMenu };","import { without } from 'lodash';\nimport { connect } from 'react-redux';\nimport { INLINES, MARKS } from '../../../content/';\n\nimport { deleteLink, insertLink, toggleMarkOnSelection } from '../../ducks/actions';\nimport { TextMenu } from './TextMenu';\nimport { Inline, Value } from 'slate';\n\nconst mapStateToProps = (state: any) => {\n    const { value, textMenu } = state;\n    const hasLinks = (value as Value).inlines.some((inline?: Inline) => Boolean(inline && inline.type === INLINES.link));\n\n    const { selectionRect: targetRect, possibleMarks } = textMenu;\n\n    const marks = (hasLinks\n        ? without(possibleMarks, MARKS.underlined)\n        : possibleMarks) || [];\n    const activeMarks = possibleMarks && value.activeMarks.toJS();\n\n    return {\n        activeMarks,\n        hasLinks,\n        targetRect,\n        marks,\n    };\n};\n\nconst mapDispatchToProps = {\n    deleteLink,\n    insertLink,\n    onToggleMark: toggleMarkOnSelection\n};\n\nconst connected = connect(mapStateToProps, mapDispatchToProps)(TextMenu);\n\nexport { connected as TextMenu };","import React, { useEffect, useState } from 'react';\n\nimport { ElementPosition, Offset, Placement, Popover } from '@lumx/react';\n\nexport function useWindowSize() {\n    const getWindowSize = () => ({\n        innerWidth: window.innerWidth,\n        innerHeight: window.innerHeight,\n    });\n    const [windowSize, setWindowSize] = useState(getWindowSize);\n    const handleResize = () => setWindowSize(getWindowSize());\n    useEffect(() => {\n        window.addEventListener('resize', handleResize);\n        return () => {\n            window.removeEventListener('resize', handleResize);\n        }\n    });\n    return windowSize;\n}\n\nexport function useWindowScroll() {\n    const getWindowScroll = () => ({\n        scrollX: window.scrollX,\n        scrollY: window.scrollY,\n    });\n    const [windowScroll, setWindowScroll] = useState(getWindowScroll);\n    const handleScroll = () => setWindowScroll(getWindowScroll());\n    useEffect(() => {\n        window.addEventListener('scroll', handleScroll);\n        return () => {\n            window.removeEventListener('scroll', handleScroll);\n        }\n    });\n    return windowScroll;\n}\n\nexport function useComputePositionFromRect(\n    placement: Placement,\n    targetRect: ElementPosition,\n    popoverRef: React.RefObject<HTMLDivElement>,\n    isVisible: boolean,\n    offset?: Offset,\n    staysOpenOnHover?: boolean,\n    hasParentWidth?: boolean,\n    hasParentHeight?: boolean,\n    dependencies?: any[],\n    callback?: (position: ElementPosition) => void\n) {\n    const [anchorRef, setAnchorRef] = useState({ current: null as any });\n    useEffect(() => {\n        setAnchorRef({ current: { getBoundingClientRect: () => targetRect } });\n    }, [targetRect]);\n\n    return Popover.useComputePosition(\n        placement,\n        anchorRef,\n        popoverRef,\n        isVisible,\n        offset,\n        staysOpenOnHover,\n        hasParentWidth,\n        hasParentHeight,\n        dependencies,\n        callback\n    );\n}","import React, { RefObject } from 'react';\n\nimport { Dropdown, List, ListItem } from '@lumx/react';\nimport { isEmpty } from 'lodash';\nimport { BLOCK_COMPONENTS, BLOCKS } from '../../../content';\nimport { Block } from 'slate';\n\n// TODO: translation.\nconst LABELS = {\n    [BLOCKS.body]: 'Body text',\n    [BLOCKS.headline]: 'Headline',\n    [BLOCKS.title]: 'Title',\n    [BLOCKS.subtitle]: 'Subtitle',\n    [BLOCKS.preformatted]: 'Preformatted',\n};\n\n/**\n * Block preview displaying the block name using the actual Block render component.\n */\nconst BlockPreview = ({ type }: { type: string }) => {\n    const BlockComponent = BLOCK_COMPONENTS[type];\n    return <BlockComponent node={{ type } as Block}>{LABELS[type]}</BlockComponent>\n};\n\ninterface IProps {\n    blockType: string;\n    buttonRef: RefObject<HTMLButtonElement>;\n    dropdownBlockTypes: string[],\n    isBlockTypeDropdownOpen: boolean,\n\n    changeBlockType(type: string): void,\n\n    setBlockTypeDropdownOpen(isOpen: boolean): void\n}\n\nexport const BlockTypeDropdown: React.FC<IProps> = (props) => {\n    const {\n        blockType,\n        buttonRef,\n        changeBlockType,\n        dropdownBlockTypes,\n        isBlockTypeDropdownOpen,\n        setBlockTypeDropdownOpen\n    } = props;\n\n    return (\n        <Dropdown\n            className=\"editor-menu\"\n            anchorRef={buttonRef}\n            showDropdown={!isEmpty(dropdownBlockTypes) && isBlockTypeDropdownOpen}\n            onClose={() => isBlockTypeDropdownOpen && setBlockTypeDropdownOpen(false)}\n        >\n            <List>\n                {dropdownBlockTypes.map((type) => {\n                    const onClick = () => changeBlockType(type);\n                    return (\n                        <ListItem\n                            isClickable\n                            key={type}\n                            isSelected={type === blockType}\n                            onClick={onClick}\n                            onTouchStart={onClick}\n                        >\n                            <BlockPreview type={type}/>\n                        </ListItem>\n                    );\n                })}\n            </List>\n        </Dropdown>\n    );\n};","import { connect } from 'react-redux';\nimport { changeBlockType, setBlockTypeDropdownOpen } from '../../ducks/actions';\nimport { BlockTypeDropdown } from './BlockTypeDropdown';\n\nconst mapStateToProps = (state: any) => {\n    return {\n        isBlockTypeDropdownOpen: state.isBlockTypeDropdownOpen,\n    }\n};\n\nconst mapDispatchToProps = {\n    setBlockTypeDropdownOpen,\n    changeBlockType,\n};\n\nconst connected = connect(mapStateToProps, mapDispatchToProps)(BlockTypeDropdown);\n\nexport { connected as BlockTypeDropdown };","import {\n    mdiFormatAlignCenter,\n    mdiFormatAlignLeft,\n    mdiFormatAlignRight,\n    mdiFormatListBulleted,\n    mdiFormatListNumbered,\n    mdiFormatParagraph,\n    mdiMenuDown\n} from '@lumx/icons';\n\nimport { Button, ColorPalette, Emphasis, IconButton, Placement, Popover } from '@lumx/react';\nimport { intersection, isEmpty } from 'lodash';\nimport React, { RefObject, useRef } from 'react';\nimport { BLOCKS } from '../../../content/';\nimport { Align } from '../../../content/schema';\nimport { BlockTypeDropdown } from '../BlockTypeDropdown';\n\nconst ALIGN_ICONS = {\n    [Align.center]: mdiFormatAlignCenter,\n    [Align.left]: mdiFormatAlignLeft,\n    [Align.right]: mdiFormatAlignRight,\n};\nconst BLOCK_TYPE_ICONS = {\n    [BLOCKS.unorderedlist]: mdiFormatListBulleted,\n    [BLOCKS.orderedlist]: mdiFormatListNumbered,\n};\nconst ALL_DROPDOWN_TYPES = [BLOCKS.body, BLOCKS.headline, BLOCKS.title, BLOCKS.subtitle, BLOCKS.preformatted];\nconst ALL_ICON_TYPES = [BLOCKS.unorderedlist, BLOCKS.orderedlist];\n\ninterface IProps {\n    activeBlockIndex: number,\n    anchorRef: RefObject<HTMLElement>,\n    blockAlign: string,\n    possibleAlignOptions: string[];\n    blockType: string;\n    possibleBlockTypes: string[];\n    isBlockTypeDropdownOpen: boolean;\n\n    changeBlockAlign(align: string): void,\n\n    changeBlockType(type: string): void;\n\n    setBlockTypeDropdownOpen(isOpen: boolean): void;\n}\n\nconst BlockMenu: React.FC<IProps> = (props) => {\n    const {\n        activeBlockIndex,\n        anchorRef,\n        changeBlockAlign,\n        blockAlign,\n        possibleAlignOptions,\n        changeBlockType,\n        blockType,\n        possibleBlockTypes,\n        setBlockTypeDropdownOpen,\n        isBlockTypeDropdownOpen\n    } = props;\n    const popoverRef = useRef(null);\n    const { computedPosition: popoverRect, isVisible } = Popover.useComputePosition(\n        Placement.BOTTOM_START,\n        anchorRef,\n        popoverRef,\n        true,\n        undefined,\n        true,\n        false,\n        false,\n        [activeBlockIndex, anchorRef]\n    );\n\n    const onClickBlockTypes = () => setBlockTypeDropdownOpen(!isBlockTypeDropdownOpen);\n\n    const dropdownBlockTypes = intersection(ALL_DROPDOWN_TYPES, possibleBlockTypes);\n    const iconBlockTypes = intersection(ALL_ICON_TYPES, possibleBlockTypes);\n    const buttonRef = useRef(null);\n\n\n    const changeType = (type: string) => () => changeBlockType(type);\n\n    return (\n        <>\n            {isBlockTypeDropdownOpen && (\n                <BlockTypeDropdown\n                    buttonRef={buttonRef}\n                    blockType={blockType}\n                    dropdownBlockTypes={dropdownBlockTypes}\n                />\n            )}\n            <Popover\n                isVisible={isVisible}\n                className=\"editor-menu\"\n                elevation={0}\n                popoverRef={popoverRef}\n                popoverRect={popoverRect}\n            >\n                <div className=\"editor-hovering-menu editor-menu__content\">\n                    {possibleAlignOptions.map((align) => {\n                        const onClick = () => changeBlockAlign(align);\n                        return (\n                            <IconButton\n                                key={align}\n                                color={ColorPalette.light}\n                                emphasis={Emphasis.low}\n                                isSelected={blockAlign === align}\n                                icon={ALIGN_ICONS[align as Align]}\n                                onClick={onClick}\n                                onTouchStart={onClick}\n                            />\n                        );\n                    })}\n\n                    {!isEmpty(dropdownBlockTypes) && (\n                        <Button\n                            buttonRef={buttonRef}\n                            color={ColorPalette.light}\n                            emphasis={Emphasis.low}\n                            leftIcon={mdiFormatParagraph}\n                            rightIcon={mdiMenuDown}\n                            onClick={onClickBlockTypes}\n                            onTouchStart={onClickBlockTypes}\n                        />\n                    )}\n\n                    {iconBlockTypes.map((type) => (\n                        <IconButton\n                            key={type}\n                            color={ColorPalette.light}\n                            emphasis={Emphasis.low}\n                            isSelected={blockType === type}\n                            icon={BLOCK_TYPE_ICONS[type]}\n                            onClick={changeType(type)}\n                        />\n                    ))}\n                </div>\n            </Popover>\n        </>\n    );\n};\n\nexport { BlockMenu };","import { connect } from 'react-redux';\nimport { changeBlockAlign, changeBlockType, setBlockTypeDropdownOpen } from '../../ducks/actions';\nimport { getSchemaForNode } from '../../ducks/selectors';\nimport { getNodeData } from '../../utils';\nimport { BlockMenu } from './BlockMenu';\n\nconst mapStateToProps = (state: any) => {\n    const { value, activeBlockIndex, isBlockTypeDropdownOpen } = state;\n    const activeNode = activeBlockIndex && value.getIn(['document', 'nodes', activeBlockIndex]);\n    const blockSchema = getSchemaForNode(state, activeNode);\n    const blockAlign = getNodeData(activeNode, 'align', blockSchema);\n    const blockType = activeNode && activeNode.type;\n\n    return {\n        activeBlockIndex,\n        blockAlign,\n        blockType,\n        isBlockTypeDropdownOpen,\n    }\n};\n\nconst mapDispatchToProps = {\n    changeBlockAlign,\n    changeBlockType,\n    setBlockTypeDropdownOpen,\n};\n\nconst connected = connect(mapStateToProps, mapDispatchToProps)(BlockMenu);\n\nexport { connected as BlockMenu };","import React, { RefObject } from 'react';\nimport { filterImages, IMAGE_TYPES, readAsDataURL } from '../utils';\nimport { IGenericProps } from '@lumx/react/lumx.react';\n\ninterface IProps extends IGenericProps {\n    fileInputRef: RefObject<HTMLInputElement>;\n\n    onChange(dataURLs: string[]): void;\n}\n\nexport const ImageInput: React.FC<IProps> = (props) => {\n    const {\n        fileInputRef,\n        onChange,\n        ...forwardedProps\n    } = props;\n\n    const fileSelectChange = async ({ target }: { target: any }) => {\n        if (target.files) {\n            const images = filterImages([...target.files]);\n            const dataURLs = await Promise.all(\n                images.map(readAsDataURL)\n            );\n            onChange(dataURLs);\n        }\n    };\n\n    return (\n        <input\n            ref={fileInputRef}\n            accept={IMAGE_TYPES.join((', '))}\n            type=\"file\"\n            onChange={fileSelectChange}\n            {...forwardedProps}\n        />\n    )\n};","import { connect } from 'react-redux';\nimport { insertImage, setBlockMenuOpen } from '../../ducks/actions';\nimport { InsertMenu } from './InsertMenu';\n\nconst mapStateToProps = (state: any) => {\n    return {\n        activeBlockIndex: state.activeBlockIndex,\n        isBlockMenuOpen: state.isBlockMenuOpen\n    }\n};\n\nconst mapDispatchToProps = {\n    setBlockMenuOpen,\n    insertImage\n};\n\nconst connected = connect(mapStateToProps, mapDispatchToProps)(InsertMenu);\n\nexport { connected as InsertMenu };","import { mdiImage } from '@lumx/icons';\nimport { Dropdown, Icon, List, ListItem, ListItemSize, Size } from '@lumx/react';\nimport React, { Ref, RefObject, useRef } from 'react';\nimport { ImageInput } from '../../image/insert/ImageInput';\n\ninterface IProps {\n    anchorRef: RefObject<HTMLElement>,\n    isBlockMenuOpen: boolean,\n\n    activeBlockIndex: number,\n\n    insertImage(index: number, dataURL: string): void\n    setBlockMenuOpen(isOpen: boolean): void,\n}\n\nexport const InsertMenu = ({ anchorRef, isBlockMenuOpen, setBlockMenuOpen, activeBlockIndex, insertImage }: IProps) => {\n    const fileInputRef: Ref<HTMLInputElement> = useRef(null);\n    const selectImage = () => {\n        fileInputRef.current && fileInputRef.current.click();\n    };\n    const fileInputChange = (dataURLs: string[]) => dataURLs.map((dataURL) => insertImage(activeBlockIndex, dataURL));\n\n    return (\n        <Dropdown\n            showDropdown\n            anchorRef={anchorRef}\n            onClose={() => isBlockMenuOpen && setBlockMenuOpen(false)}\n        >\n            <ImageInput\n                fileInputRef={fileInputRef}\n                style={{ display: 'none' }}\n                onChange={fileInputChange}\n            />\n            <List>\n                <ListItem\n                    isClickable\n                    isSelected={false}\n                    before={<Icon icon={mdiImage} size={Size.s}/>}\n                    size={ListItemSize.tiny}\n                    onClick={selectImage}\n                    onTouchStart={selectImage}\n                >\n                    Image\n                </ListItem>\n            </List>\n        </Dropdown>\n    );\n};","import { get } from 'lodash';\nimport { connect } from 'react-redux';\nimport { Align } from '../../../content/schema';\nimport { setBlockMenuOpen } from '../../ducks/actions';\nimport { getSchemaForNode } from '../../ducks/selectors';\nimport { memoizedGetPossibleBlocks } from '../../schema-utils';\nimport { BlockButton } from './BlockButton';\n\nconst mapStateToProps = (state: any) => {\n    const { value, schema, activeBlockIndex } = state;\n    const activeNode = activeBlockIndex && value.getIn(['document', 'nodes', activeBlockIndex]);\n    const blockType = activeNode && activeNode.type;\n    const blockSchema = activeNode && getSchemaForNode(state, activeNode);\n\n    const possibleBlockTypes = (blockSchema && !blockSchema.isVoid)\n        ? memoizedGetPossibleBlocks(schema, value.document, activeBlockIndex)\n        : [];\n\n    const possibleAlignOptions = (activeNode && get(blockSchema, ['data', 'align']) ? Object.keys(Align) : []) as Align[];\n\n    let insertMode = Boolean(activeNode && !activeNode.text && blockSchema && !blockSchema.isVoid);\n\n    return {\n        blockType,\n        possibleAlignOptions,\n        possibleBlockTypes,\n        insertMode,\n        isBlockMenuOpen: state.isBlockMenuOpen,\n    };\n};\n\nconst mapDispatchToProps = {\n    setBlockMenuOpen,\n};\n\nconst connected = connect(mapStateToProps, mapDispatchToProps)(BlockButton);\n\nexport { connected as BlockButton };","import { mdiDotsVertical, mdiPlus } from '@lumx/icons';\nimport { Emphasis, IconButton, Size } from '@lumx/react';\nimport React, { RefObject } from 'react';\n\nimport './BlockButton.scss';\nimport { BlockMenu } from '../BlockMenu/';\nimport { InsertMenu } from '../InsertMenu/';\nimport { Align } from '../../../content/schema';\n\ninterface IProps {\n    blockType: string,\n    buttonRef: RefObject<HTMLButtonElement>,\n    possibleAlignOptions: Align[],\n    possibleBlockTypes: string[],\n    insertMode: boolean,\n    isBlockMenuOpen: boolean,\n    showButton: boolean,\n\n    setBlockMenuOpen(isOpen: boolean): void,\n}\n\nexport const BlockButton: React.FC<IProps> = (props) => {\n    const {\n        blockType,\n        buttonRef,\n        possibleAlignOptions,\n        possibleBlockTypes,\n        insertMode,\n        isBlockMenuOpen,\n        setBlockMenuOpen,\n        showButton,\n    } = props;\n\n    const onClick = (evt: MouseEvent) => {\n        setBlockMenuOpen(!isBlockMenuOpen);\n        evt.preventDefault();\n        evt.stopPropagation();\n    };\n    const hasAlignOptions = Boolean(possibleAlignOptions.length);\n    const hasBlockTypeOptions = possibleBlockTypes.length > 1 || (\n        possibleBlockTypes.length === 1 && possibleBlockTypes[0] !== blockType\n    );\n    const shouldShowBlockButton = showButton && (hasAlignOptions || hasBlockTypeOptions);\n\n    return (\n        <>\n            {shouldShowBlockButton &&\n            isBlockMenuOpen && (\n                insertMode\n                    ? <InsertMenu anchorRef={buttonRef}/>\n                    : <BlockMenu\n                        anchorRef={buttonRef}\n                        possibleAlignOptions={possibleAlignOptions}\n                        possibleBlockTypes={possibleBlockTypes}\n                    />\n            )}\n            <IconButton\n                buttonRef={buttonRef}\n                emphasis={Emphasis.medium}\n                icon={insertMode ? mdiPlus : mdiDotsVertical}\n                size={Size.m}\n                style={{ visibility: shouldShowBlockButton ? 'visible' : 'hidden' }}\n                onClick={onClick}\n                onTouchStart={onClick}\n            />\n        </>\n    );\n};","// @ts-ignore\nimport lineHeight from 'line-height';\nimport React, { ReactElement, ReactNode, RefObject, useEffect, useRef, useState } from 'react';\nimport { BlockButton } from '../../menu/BlockButton';\n\nimport './BlockWrapper.scss'\nimport { List } from 'immutable';\nimport { Node } from 'slate';\n\n/**\n * Compute a dynamic style for the button to align to the line height of the block element.\n */\nfunction useStyleAlignWithLineHeight(blockRef: RefObject<HTMLElement>, buttonRef: RefObject<HTMLButtonElement>, node: Node) {\n    const [style, setStyle] = useState({});\n    useEffect(() => {\n        const blockLineHeight = blockRef && blockRef.current && lineHeight(blockRef.current);\n        const buttonHeight = buttonRef && buttonRef.current && buttonRef.current.getBoundingClientRect().height;\n        setStyle({\n            // Center to the first line of active block\n            top: -(buttonHeight || 0 - blockLineHeight) / 2\n        });\n    }, [blockRef, buttonRef, node]);\n    return style;\n}\n\ninterface IProps {\n    activeBlockIndex: number,\n    blockPath: List<string | number>,\n    blockRef: RefObject<HTMLElement>,\n    children: ReactNode,\n    isBlockMenuOpen: boolean,\n    isVoidBlock: boolean,\n    node: Node,\n\n    setActiveBlockIndex(index: number): void,\n}\n\nexport const BlockWrapper: React.FC<IProps> = (props) => {\n    const {\n        activeBlockIndex,\n        blockPath,\n        blockRef,\n        children,\n        isBlockMenuOpen,\n        isVoidBlock,\n        node,\n        setActiveBlockIndex,\n    } = props;\n    const buttonRef = useRef(null);\n    const style = useStyleAlignWithLineHeight(blockRef, buttonRef, node);\n    const isRootBlock = blockPath && blockPath.size === 1;\n\n    const blockIndex = blockPath && blockPath.first();\n    const onMouseEnter = () => {\n        if (!isBlockMenuOpen) {\n            setActiveBlockIndex(blockIndex as number);\n        }\n    };\n    const isBlockActive = activeBlockIndex === blockIndex;\n\n    return isRootBlock\n        ? (\n            <div\n                className=\"editor-block-wrapper\"\n                onMouseEnter={onMouseEnter}\n            >\n                {!isVoidBlock && (\n                    <div className=\"editor-block-wrapper__left-margin\" contentEditable={false} style={style}>\n                        <BlockButton buttonRef={buttonRef} showButton={isBlockActive}/>\n                    </div>\n                )}\n                {children}\n            </div>\n        )\n        : children as ReactElement;\n};","import { connect } from 'react-redux';\n\nimport { setActiveBlockIndex } from '../../ducks/actions';\nimport { getSchemaForNode } from '../../ducks/selectors';\nimport { BlockWrapper } from './BlockWrapper';\nimport { List } from 'immutable';\n\nconst mapStateToProps = (state: any, ownProps: any) => {\n    const { activeBlockIndex, isBlockMenuOpen, value } = state;\n    const { node } = ownProps;\n\n    const blockSchema = getSchemaForNode(state, node);\n    const isVoidBlock = Boolean(blockSchema && blockSchema.isVoid);\n\n    const blockPath = value.document.getPath(node) as List<string | number>;\n\n    return {\n        activeBlockIndex: activeBlockIndex as number,\n        blockPath,\n        isVoidBlock,\n        isBlockMenuOpen: isBlockMenuOpen as boolean,\n    };\n};\n\nconst mapDispatchToProps = {\n    setActiveBlockIndex\n};\n\nconst connected = connect(mapStateToProps, mapDispatchToProps)(BlockWrapper);\n\nexport { connected as BlockWrapper };","import { mdiClose } from '@lumx/icons';\nimport { Button, Emphasis, IconButton, Placement, Popover, Size, Theme } from '@lumx/react';\nimport React, { RefObject, useRef } from 'react';\nimport { Align, ImagePlacement } from '../../../content/schema';\nimport { getNodeData } from '../../utils';\n\nimport './ImageSettings.scss';\nimport { Block, Inline, Rules } from 'slate';\n\n/**\n * Check whether an image is displayed to its natural width\n * @param {Ref<HTMLImageElement>} imageRef Image reference\n * @return {boolean} true if the image is displayed to it's full width; false otherwise\n */\nfunction hasNaturalWidth(imageRef: RefObject<HTMLImageElement>) {\n    if (imageRef && imageRef.current) {\n        return imageRef.current.naturalWidth === imageRef.current.clientWidth;\n    }\n    return false;\n}\n\nconst LABELS = {\n    [Align.center]: 'Center',\n    [Align.right]: 'Right',\n    [Align.left]: 'Left',\n    [ImagePlacement.break]: 'Splits text',\n    [ImagePlacement.inline]: 'Wraps text',\n};\n\n\nfunction renderSize() {\n    return (\n        <>\n            <div className=\"wrex-content-figure-options__subtitle\">\n                Size\n            </div>\n            <div className=\"wrex-content-figure-options__button-choices\">\n                <Button\n                    isSelected\n                    emphasis={Emphasis.medium}\n                    theme={Theme.dark}\n                >\n                    Full width\n                </Button>\n            </div>\n        </>\n    )\n}\n\n\nfunction renderPlacement(\n    blockIndex: number,\n    imagePlacement: ImagePlacement,\n    changeImagePlacement: changeImagePlacementType,\n    imageHasNaturalWidth: boolean\n) {\n    const onClickPlacement = (placement: ImagePlacement) => () => changeImagePlacement(placement, blockIndex);\n\n    const renderButton = (placement: ImagePlacement) => (\n        <Button\n            disabled={!imageHasNaturalWidth}\n            isSelected={imagePlacement === placement}\n            emphasis={Emphasis.medium}\n            theme={Theme.dark}\n            onClick={onClickPlacement(placement)}\n        >\n            {LABELS[placement]}\n        </Button>\n    );\n\n    return (\n        <>\n            <div className=\"wrex-content-figure-options__subtitle\">\n                Text wrapping\n            </div>\n            <div className=\"wrex-content-figure-options__button-choices\">\n                {renderButton(ImagePlacement.break)}\n                {renderButton(ImagePlacement.inline)}\n            </div>\n        </>\n    )\n}\n\nfunction renderAlign(\n    blockIndex: number,\n    imageAlign: Align,\n    possibleAligns: Align[],\n    changeImageAlign: changeAlignType,\n    imageHasNaturalWidth: boolean\n) {\n    const onClickAlign = (align: Align) => () => changeImageAlign(align, blockIndex);\n    const renderButton = (align: Align) => (\n        <Button\n            disabled={!imageHasNaturalWidth}\n            key={align}\n            isSelected={imageAlign === align || (align === Align.left && !possibleAligns.includes(imageAlign))}\n            emphasis={Emphasis.medium}\n            theme={Theme.dark}\n            onClick={onClickAlign(align)}\n        >\n            {LABELS[align]}\n        </Button>\n    );\n\n    return (\n        <>\n            <div className=\"wrex-content-figure-options__subtitle\">\n                Alignment\n            </div>\n            <div className=\"wrex-content-figure-options__button-choices\">\n                {possibleAligns.map(renderButton)}\n            </div>\n        </>\n    );\n}\n\ntype changeImagePlacementType = (p: ImagePlacement, i: number) => void;\ntype changeAlignType = (p: Align, i: number) => void;\n\ninterface IProps {\n    blockIndex: number,\n    blockSchema?: Rules,\n    changeImageAlign: changeAlignType,\n    changeImagePlacement: changeImagePlacementType,\n    closeSettings: Function,\n    imageRef: RefObject<HTMLImageElement>,\n    imageHasFocus: boolean,\n    node: Block | Inline,\n}\n\nexport const ImageSettings: React.FC<IProps> = (props) => {\n    const {\n        blockIndex,\n        blockSchema,\n        changeImageAlign,\n        changeImagePlacement,\n        closeSettings,\n        imageRef,\n        imageHasFocus,\n        node,\n    } = props;\n\n    const popoverRef = useRef(null);\n    const { computedPosition: popoverRect, isVisible } = Popover.useComputePosition(\n        Placement.RIGHT,\n        imageRef,\n        popoverRef,\n        imageHasFocus,\n        undefined,\n        imageHasFocus,\n        false,\n        false,\n        [imageRef, node]\n    );\n\n    const closeButtonRef = useRef(null);\n    const onMouseDown = (evt: MouseEvent) => {\n        evt.stopPropagation();\n        evt.preventDefault();\n    };\n\n    const imagePlacement = getNodeData(node, 'placement', blockSchema);\n    const imageAlign = getNodeData(node, 'align', blockSchema);\n    const possibleAligns = imagePlacement === ImagePlacement.inline\n        ? [Align.left, Align.right]\n        : [Align.left, Align.center, Align.right];\n\n    const imageHasNaturalWidth = hasNaturalWidth(imageRef);\n    return (\n        <Popover\n            className=\"editor-menu wrex-content-figure-options\"\n            isVisible={isVisible}\n            popoverRef={popoverRef}\n            popoverRect={popoverRect}\n            elevation={0}\n            tabIndex={-1}\n            onMouseDown={onMouseDown}\n        >\n            <div className=\"wrex-content-figure-options__content editor-hovering-menu editor-menu__content\">\n                <div className=\"wrex-content-figure-options__header\">\n                    <div className=\"wrex-content-figure-options__title\">Image options</div>\n                    <IconButton\n                        buttonRef={closeButtonRef}\n                        className=\"wrex-content-figure-options__close\"\n                        icon={mdiClose}\n                        size={Size.m}\n                        theme={Theme.dark}\n                        emphasis={Emphasis.low}\n                        onClick={closeSettings}\n                    />\n                </div>\n\n                {renderSize()}\n\n                {renderPlacement(blockIndex, imagePlacement, changeImagePlacement, imageHasNaturalWidth)}\n\n                {renderAlign(blockIndex, imageAlign, possibleAligns, changeImageAlign, imageHasNaturalWidth)}\n            </div>\n        </Popover>\n    );\n};","import { connect } from 'react-redux';\nimport { blurCurrentBlock, changeBlockAlign, changeImagePlacement } from '../../ducks/actions';\nimport { getSchemaForNode } from '../../ducks/selectors';\nimport { ImageSettings } from './ImageSettings';\n\nconst mapStateToProps = (state: any, ownProps: any) => {\n    const { value } = state;\n    const { node } = ownProps;\n\n    const blockPath = value.document.getPath(node);\n    const blockIndex = blockPath && blockPath.first();\n\n    const blockSchema = getSchemaForNode(state, node);\n\n    return {\n        blockIndex: blockIndex as number,\n        blockSchema,\n    };\n};\n\nconst mapDispatchToProps = {\n    changeImageAlign: changeBlockAlign,\n    changeImagePlacement,\n    closeSettings: blurCurrentBlock,\n};\n\nconst connected = connect(mapStateToProps, mapDispatchToProps)(ImageSettings);\n\nexport { connected as ImageSettings };","import { connect } from 'react-redux';\nimport { ImageEditor } from './ImageEditor';\n\nconst mapStateToProps = (state: any, ownProps: any) => {\n    const { value } = state;\n    const { node } = ownProps;\n    const blockHasFocus = value.selection.isFocused && value.startBlock === node;\n\n    return {\n        blockHasFocus,\n    };\n};\n\nconst mapDispatchToProps = {};\n\nconst connected = connect(mapStateToProps, mapDispatchToProps)(ImageEditor);\n\nexport { connected as ImageEditor };","import classNames from 'classnames';\nimport React, { RefObject, useRef } from 'react';\nimport { Image } from '../../../content/block/Image';\nimport { ImageSettings } from '../ImageSettings/';\n\nimport './ImageEditor.scss';\nimport { Block } from 'slate';\n\ninterface IProps {\n    className: string,\n    blockHasFocus: boolean,\n    elementRef: RefObject<HTMLElement>,\n    node: Block,\n}\n\n/**\n * Wraps the <Image> component to add interaction during edition.\n */\nexport const ImageEditor: React.FC<IProps> = (props) => {\n    const {\n        className,\n        blockHasFocus,\n        elementRef,\n        node,\n        ...forwardedProps\n    } = props;\n    const imageRef = useRef(null);\n\n    return (\n        <>\n            <Image\n                className={classNames(\n                    className,\n                    blockHasFocus && 'wrex-content-figure--has-focus'\n                )}\n                elementRef={elementRef}\n                imageRef={imageRef}\n                node={node}\n                {...forwardedProps}\n            />\n            <ImageSettings\n                imageRef={imageRef}\n                imageHasFocus={blockHasFocus}\n                node={node}\n            />\n        </>\n    );\n};\n","// @ts-ignore\nimport PlaceholderPlugin from 'slate-react-placeholder';\n\nimport { curry } from 'lodash';\nimport { Block, Editor, Inline, Node, Rules, SchemaProperties } from 'slate';\nimport { HasHelper } from '../../SCHEMA';\n\nconst isOfType = curry((type: string, node?: Node) =>\n    (node instanceof Block || node instanceof Inline) && node.type !== type);\n\n/**\n * Extract placeholder plugin configurations from the block schema.\n *\n * @param schema\n * @return {Array} List of placeholder configs\n */\nexport function getPlaceholderPluginConfigFromSchema(schema: SchemaProperties) {\n    const configs: PlaceholderPlugin[] = [];\n\n    const blockEntries: [string, Rules & HasHelper][] = Object.entries(schema.blocks ||{});\n    for (const [blockType, block] of blockEntries) {\n        if (!block.helper) continue;\n\n        configs.push(new PlaceholderPlugin({\n            placeholder: block.helper,\n            style: {\n                verticalAlign: 'unset'\n            },\n            when(editor: Editor, node: Node) {\n                const isCorrectType = isOfType(blockType);\n                if (!isCorrectType(node)) {\n                    return false;\n                }\n                // Check if the empty block has siblings of its kind (same block type)\n                const hasOtherOfItsKind = editor.value.document.nodes.some(isCorrectType);\n                return !hasOtherOfItsKind;\n            }\n        }));\n    }\n\n    return configs;\n}","import React, { RefObject, useEffect, useMemo, useRef } from 'react';\n// @ts-ignore\nimport CollapseOnEscape from 'slate-collapse-on-escape';\n// @ts-ignore\nimport SoftBreak from 'slate-soft-break';\nimport { Editor, EditorProps, RenderBlockProps, RenderInlineProps, RenderMarkProps } from 'slate-react';\nimport { Editor as CoreEditor } from 'slate';\n\nimport { BLOCK_COMPONENTS, BLOCKS, INLINE_COMPONENTS, MARK_COMPONENTS } from '../../content/';\nimport { useWindowScroll, useWindowSize } from '../hooks';\nimport { DropPasteImagePlugin } from '../image/insert/DropPasteImagePlugin';\nimport { TextMenu } from '../menu/TextMenu';\nimport { BlockWrapper } from '../menu/BlockWrapper/';\nimport { ImageEditor } from '../image/ImageEditor';\nimport { getPlaceholderPluginConfigFromSchema } from './placeholder';\nimport { IGenericProps } from '@lumx/react/lumx.react';\n\n\ntype NextFunction = () => any;\n\n/**\n * Render mark node as component.\n */\nconst renderMark = (props: RenderMarkProps, editor: CoreEditor, next: NextFunction): any => {\n    const { children, mark } = props;\n    const { ref, ...attributes } = props.attributes;\n\n    const Mark = MARK_COMPONENTS[mark.type];\n    if (Mark) {\n        return <Mark elementRef={ref} mark={mark} {...attributes}>{children}</Mark>;\n    }\n    return next();\n};\n\n/**\n * Render inline node as component.\n */\nconst renderInline = (props: RenderInlineProps, editor: CoreEditor, next: NextFunction): any => {\n    const { children, node } = props;\n    const { ref, ...attributes } = props.attributes;\n\n    const Inline = INLINE_COMPONENTS[node.type];\n    if (Inline) {\n        return <Inline elementRef={ref} node={node} {...attributes}>{children}</Inline>;\n    }\n\n    return next();\n};\n\n/**\n * Render block node as component. Wrap the basic content component if needed.\n */\nconst renderBlock = (blockIndex: number, props: RenderBlockProps, editor: CoreEditor, next: NextFunction): any => {\n    const { children, node } = props;\n    const { ref, ...attributes } = props.attributes;\n\n    const Block = (node.type === BLOCKS.image)\n        ? ImageEditor\n        : BLOCK_COMPONENTS[node.type];\n    if (Block) {\n        return <Block elementRef={ref} node={node} {...attributes}>{children}</Block>;\n    }\n\n    return next();\n};\n\n/**\n * Render block wrapper that add a margin to the left with the BlockButton.\n */\nconst renderBlockWrapper = (props: RenderBlockProps, editor: CoreEditor, next: NextFunction): any => {\n    const { attributes, node } = props;\n    const blockIndex = editor.value.document.nodes.indexOf(node);\n    return (\n        <BlockWrapper node={node} blockRef={attributes['ref']}>\n            {renderBlock(blockIndex, props, editor, next)}\n        </BlockWrapper>\n    );\n};\n\n// TODO: remove\n// @ts-ignore\ntype EditorSetter = ({ editor: CoreEditor }) => void;\nconst renderEditor = (setEditor: EditorSetter, editorRef: RefObject<Editor>) =>\n    (_: EditorProps, editor: CoreEditor, next: NextFunction): any => {\n        setEditor({ editor });\n        if (!editorRef.current) {\n            // @ts-ignore\n            editorRef.current = editor;\n        }\n        return next();\n    };\n\nconst WXPEditor = (props: IGenericProps) => {\n    const {\n        schema,\n        value,\n        onChange,\n        setEditor,\n        updateTextMenu,\n        insertImage,\n        isTextMenuOpen,\n        ...forwardedProps\n    } = props;\n\n    const plugins = useMemo(() => [\n        // Collapse selection on esc.\n        CollapseOnEscape(),\n        // Insert image (on drop, on paste).\n        DropPasteImagePlugin(insertImage),\n        // Block placeholders.\n        ...getPlaceholderPluginConfigFromSchema(schema),\n        // Enable soft break (shift+enter).\n        SoftBreak({ shift: true })\n    ], [schema, insertImage]);\n\n    // Update menu locations on window resize & scroll.\n    const windowSize = useWindowSize();\n    const windowScroll = useWindowScroll();\n    useEffect(() => {\n        updateTextMenu();\n    }, [updateTextMenu, windowSize, windowScroll]);\n\n    const editorRef = useRef(null);\n\n    return (\n        <>\n            <Editor\n                ref={editorRef}\n                className=\"editor\"\n                renderBlock={renderBlockWrapper}\n                renderEditor={renderEditor(setEditor, editorRef)}\n                renderInline={renderInline}\n                renderMark={renderMark}\n                schema={schema}\n                value={value}\n                onChange={onChange}\n                plugins={plugins}\n                {...forwardedProps}\n            />\n\n            {isTextMenuOpen && <TextMenu/>}\n        </>\n    );\n};\n\n\nexport { WXPEditor };","import { connect } from 'react-redux';\nimport { insertImage, onChange, setEditor, updateTextMenu } from '../ducks/actions';\nimport { WXPEditor } from './WXPEditor';\n\nconst mapDispatchToProps = {\n    onChange,\n    setEditor,\n    updateTextMenu,\n    insertImage,\n};\n\nconst mapStateToProps = (state: any) => ({\n    value: state.value,\n    schema: state.schema,\n    isTextMenuOpen: state.textMenu.isOpen,\n});\n\nconst connectedWXPEditor = connect(mapStateToProps, mapDispatchToProps)(WXPEditor);\n\nexport { connectedWXPEditor as WXPEditor };","// @ts-ignore\nimport InsertImages from 'slate-drop-or-paste-images';\nimport { IMAGE_EXTENSIONS, readAsDataURL } from '../utils';\nimport { Editor } from 'slate';\n\n/**\n * Configure InsertImages slate plugin.\n */\nexport const DropPasteImagePlugin = (insertImage: Function) => InsertImages({\n    extensions: IMAGE_EXTENSIONS,\n    insertImage: async (editor: Editor, file: Blob) => {\n        const blockIndex = editor.value.document.nodes.indexOf(editor.value.endBlock);\n        const dataURL = await readAsDataURL(file);\n        insertImage(blockIndex, dataURL);\n    }\n});","import { Button, Size, UserBlock } from '@lumx/react';\nimport '@lumx/react/lumx-theme-lumapps.css'\nimport 'focus-visible';\nimport React from 'react';\nimport { Provider } from 'react-redux';\nimport { applyMiddleware, compose, createStore } from 'redux';\n\nimport thunk from 'redux-thunk';\nimport './App.scss';\nimport { reducer } from './editor/ducks/reducer';\nimport { WXPEditor } from './editor/WXPEditor';\n\n/*\n *\n * TODO WYSIWYG:\n *  - Isolate content component\n *      - Isolate style\n *      - Create edition component wrapper (If needed)\n *  - Mobile browser compatibility\n *      - Better onClick/onTouchStart handler\n *  - Add basic shortcuts\n *      - MD list shortcut (/[\\-\\*]\\s/)\n *      - meta+b => Bold\n *      - meta+u => Underline\n *      - meta+i => Italics\n *  - Advanced copy/paste\n *      - Paste keep soft break https://github.com/ianstormtaylor/slate-plugins/issues/52\n *      - ?? Paste from HTML website ??\n *      - ?? Paste from GDrive or Word ??\n *  - ?? block drag and drop\n *  - Handle translation EVERYWHERE\n *  - REFACTOR: remove redux, use plugins\n *  - ?? Insert body rather than title/subtitle/headline on enter\n *  - FEAT: make the editor usable as a library\n *      - Extendable blocks: (add user/feed mention block from outside)\n *      - Webpack build config\n *      - NPM package publish config\n *\n * TODO list unordered/ordered:\n *  - Keyboard interaction (tab, enter, del, etc.)\n *  - Multiple level list\n *  - Auto merge unordered list and ordered list items\n *\n * TODO image:\n *  - Disable align/placement settings on small screen\n *  - Display arrow on settings popover\n *  - Edit Ratio & Size\n *  - Edit caption\n *  - Light box zoom preview on click (in view mode only)\n *\n * TODO table:\n *  - Add block types\n *  - Render as void block (non editable)\n *\n * TODO menus:\n *  - Keyboard nav\n *  - One plugin for each menu\n *\n * TODO minor:\n *  - Add lumapps ESLint/TSLint rules\n *  - Disable TS implicit any\n *  - ?? Better update placeholder on previous block deleted\n *  - warn user when image format is not supported\n *  - [DS] Better popover offset with outside div (to block mouse leave)\n *  - [DS] Better popover auto placement\n *  - [PERF] On big document\n *\n * TODO serialize:\n *  - DITA serialize/deserialize\n *\n * TODO view only mode:\n *  - Create a view mode\n *      - displays DITA directly\n *          - ?Faster?\n *          - ?Semantic HTML5 section/article nested structure?\n *      - OR use slate model as intermediate\n *          - Re-use of code with DITA deserializer\n *\n */\n\n// @ts-ignore\nconst REDUX_DEVTOOLS = window['__REDUX_DEVTOOLS_EXTENSION_COMPOSE__'];\nconst composeEnhancers = REDUX_DEVTOOLS || compose;\nconst enhancer = composeEnhancers(applyMiddleware(thunk));\nconst store = createStore(\n    reducer,\n    enhancer\n);\n\nfunction App() {\n    return (\n        <Provider store={store}>\n            <section className=\"card\">\n                <header>\n                    <UserBlock\n                        name=\"Sergy Sergio\"\n                        fields={['Product manager']}\n                        avatar=\"http://i.pravatar.cc/40\"\n                        size={Size.m}\n                    />\n                </header>\n                <WXPEditor spellCheck={false}/>\n                <footer>\n                    <Button disabled>Publish</Button>\n                </footer>\n            </section>\n        </Provider>\n    );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(<App/>, document.getElementById('root'));\n"],"sourceRoot":""}